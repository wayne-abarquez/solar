(function(){
    'use strict';

    angular
        .module('solarApp', ['ngMaterial', 'ngAnimate', 'restangular', 'oitozero.ngSweetAlert', 'ngFileUpload', 'treasure-overlay-spinner', 'angularInlineEdit', 'colorpicker.module', 'md.data.table'])

        .config(['RestangularProvider', function(RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }])

        .value('SOLAR_STATUSES', [
            'In-Process',
            'Submitted',
            'Approved'
        ]);

    //.run(function (editableOptions, editableThemes) {
    //    editableThemes['angular-material'] = {
    //        formTpl: '<form class="editable-wrap"></form>',
    //        noformTpl: '<span class="editable-wrap"></span>',
    //        controlsTpl: '<md-input-container class="editable-controls" ng-class="{\'md-input-invalid\': $error}"></md-input-container>',
    //        inputTpl: '',
    //        errorTpl: '<div ng-messages="{message: $error}"><div class="editable-error" ng-message="message">{{$error}}</div></div>',
    //        buttonsTpl: '<span class="editable-buttons"></span>',
    //        submitTpl: '<md-button type="submit" class="md-primary"><md-icon style="color:white;">save</md-icon></md-button>',
    //        cancelTpl: '<md-button type="button" class="md-warn" ng-click="$form.$cancel()">cancel</md-button>'
    //    };
    //
    //    editableOptions.theme = 'angular-material';
    //});

    //.config(function ($mdThemingProvider) {
    //    $mdThemingProvider.theme('default')
    //        .primaryPalette('red')
    //        .accentPalette('pink');
    //});

    console.log('solar app initialized!');

}());


(function(){
'use strict';

angular.module('solarApp')
    .factory('webServices', ['webRequestServices', webServices]);
    
    function webServices(webRequestServices) {
        var service = {};

        service.getSolars = getSolars;
        service.getSolarDetail = getSolarDetail;
        service.updateSolar = updateSolar;

        function getSolars () {
            return webRequestServices.get('/api/solars');
        }

        function getSolarDetail (solarId) {
            console.log('getsolardetail solarID : ' + solarId);

            return webRequestServices.get('/api/solars/' + solarId);
        }

        function updateSolar (solarId, data) {
            return webRequestServices.put('/api/solars/' + solarId, data);
        }
        
        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('webRequestServices', ['$http', 'Upload', webRequestServices]);
    
    function webRequestServices($http, Upload) {
        var service = {};

        // fix 401 errors being automatically handled by browsers
        var baseUrl = location.protocol + "//" + "user:pass@" + location.host + "/";

        function buildParams(params) {
            if (params != null && params.isObject)
                return _.map(params, function (key, val) {
                    return key + "=" + value;
                }).join("&");
            return "";
        };


        service.get = function (url, params) {
            return $http.get(baseUrl + url + "?" + buildParams(params));
        };


        service.post = function (url, params) {
            return $http({
                url: baseUrl + url,
                method: "POST",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.put = function (url, params) {
            return $http({
                url: baseUrl + url,
                method: "PUT",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.delete = function (url) {
            return $http.delete(url);
        };


        service.upload = function (url, fields, file) {
            return Upload.upload({
                url: baseUrl + url,
                method: 'POST',
                fields: fields,
                file: file
            });
        };


        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('utilServices', [utilServices]);

    function utilServices () {
        var service = {};

        var hexChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

        service.byteToHex = byteToHex;

        /**
         * 0-255 to 00-ff
         * @param b
         */
        function byteToHex(b) {
            return hexChar[(b >> 4) & 0x0f] + hexChar[b & 0x0f];
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('uploadServices', ['$q', 'loaderServices', 'alertServices', uploadServices]);

    function uploadServices ($q, loaderServices, alertServices) {
        var service = {};

        service.uploadSolarPhoto = uploadSolarPhoto;
        service.updateSolarPhoto = updateSolarPhoto;
        service.parseScreenshotPhoto = parseScreenshotPhoto;


        function uploadSolarPhoto (file, solar) {
            var f = file;
            var dfd = $q.defer();

            if(f) {
                loaderServices.showLoader();
                // if file is valid
                // trigger a modal to show progress and
                solar.upload(file)
                    .then( function (response) {
                        alertServices.showFileUploadSuccess();
                        dfd.resolve(response.data);
                    }, function(errResponse){
                        alertServices.showInvalidFileUpload();
                        dfd.reject(errResponse);
                    })
                    .finally(function(){
                        loaderServices.hideLoader();
                    });
            }
            return dfd.promise;
        }

        function updateSolarPhoto(file, solar, solarFile) {
            var dfd = $q.defer();

            if (file) {
                loaderServices.showLoader();
                // if file is valid
                // trigger a modal to show progress and
                solar.updateSolarPhoto(file, solarFile.id)
                    .then(function (response) {
                        alertServices.showFileUploadSuccess();
                        dfd.resolve(response.data);
                    }, function (errResponse) {
                        alertServices.showInvalidFileUpload();
                        dfd.reject(errResponse);
                    })
                    .finally(function () {
                        loaderServices.hideLoader();
                    });
            }
            return dfd.promise;
        }

        function parseScreenshotPhoto (blob) {
            var file = null;

            var date = new Date();
            var dateString = date.getTime();
            var filename = "screenshot-" + dateString + ".png";

            try {
                file = new File([blob], filename, {type: blob.type});
            } catch (err) {
                file = blob;
                file.name = filename;
                file.type = blob.type;
            }
            return file;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('Solars', ['Restangular', 'Upload', Solars]);
    
    function Solars (Restangular, Upload) {
        var solarModel = Restangular.all('solars');

        Restangular.extendModel('solars', function (model) {

            model.deletePanel = function (panel_id) {
                return model
                    .one('panels', panel_id)
                    .remove();
            };

            model.upload = function (_file, _caption) {
                var uploadUrl = model.getRestangularUrl() + '/' + 'photos',
                    caption = _caption || '';

                console.log('custom solar method : upload');

                return Upload.upload({
                           url: uploadUrl,
                           method: 'POST',
                           data: {file: _file, caption: caption}
                       });
            };

            model.updateSolarPhoto = function (_file, solarFileId) {
                var uploadUrl = model.getRestangularUrl() + '/photos/' + solarFileId;

                console.log('custom solar method : updateSolarPhoto');

                return Upload.upload({
                    url: uploadUrl,
                    method: 'POST',
                    data: {file: _file}
                });
            };

            model.deletePhoto = function (photo) {
                console.log('custom solar method : deletePhoto');

                return model
                    .one('photos', photo.id)
                    .remove();
            };

            model.updatePhotoCaption = function (solarFile, newCaption) {
                console.log('custom solar method : updatePhotoCaption');

                return model
                        .one('photos', solarFile.id)
                        .customPUT({caption: newCaption});
            };

            return model;
        });

        return solarModel;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('solarPanelServices', ['$q', '$timeout', 'drawingServices', 'gmapServices', solarPanelServices]);

    function solarPanelServices ($q, $timeout, drawingServices, gmapServices) {
        var service = {};

        service.panels = [];
        service.panelStrokeColor = '#ff0000';
        service.lastSelectedPanel = null;

        service.initializeDrawPanel = initializeDrawPanel;
        service.initializePanels = initializePanels;
        service.hidePanels = hidePanels;
        service.hidePanelById = hidePanelById;
        service.showPanelById = showPanelById;
        service.createPanelPolygon = createPanelPolygon;
        service.createPanel = createPanel;
        service.savePanel = savePanel;
        service.updatePanel = updatePanel;
        service.findPanelById = findPanelById;
        service.deletePanel = deletePanel;
        service.onPanelClick = onPanelClick;
        service.clearSelectedPanel = clearSelectedPanel;
        //service.fillPanel = fillPanel;
        //service.removeFillPanel = removeFillPanel;

        function initializeDrawPanel () {
            drawingServices.startDrawingMode(service.panelStrokeColor);
        }

        function initializePanels (rawPanels) {
            if (rawPanels.length) {
                service.panels = angular.copy(rawPanels);
                // Show Solar Panels
                // by creating polygons on map
                service.panels.forEach(function (panel, index) {
                    service.panels[index].polygon = gmapServices.createPolygon(panel.area, service.panelStrokeColor);
                });
                console.log('panels initialied');
            }
        }

        function hidePanels () {
            service.panels.forEach(function (panel) {
                if (panel.polygon) {
                    gmapServices.hidePolygon(panel.polygon);
                    panel.polygon = null;
                }
            });

            service.panels = [];
        }

        // id which is primary key in database
        function hidePanelById (panelId) {
            var panel = findPanelById(panelId);

            if(panel.polygon) {
                gmapServices.hidePolygon(panel.polygon);
                return panel;
            }
            return null;
        }

        function showPanelById (panelId) {
            var panel = findPanelById(panelId);

            if (panel.polygon) {
                gmapServices.showPolygon(panel.polygon);
                return panel;
            }
            return null;
        }

        function createPanelPolygon (pointsArray) {
            return gmapServices.initPolygon(pointsArray, service.panelStrokeColor);
        }

        function createPanel (polygon) {
            var time = new Date().getTime();

            return {
                'name': 'Panel-' + time,
                'area': drawingServices.getAreaFormData(polygon)
            };
        }

        function savePanel (solar) {
            var dfd = $q.defer();

            var polygon = service.createPanelPolygon(drawingServices.overlayDataArray);
            var panel = service.createPanel(polygon);

            solar.all('panels').post(panel)
                .then(function (response) {

                    response.polygon = polygon;
                    gmapServices.showPolygon(polygon);

                    var newPanel = response.panel;
                    newPanel.polygon = polygon;

                    service.panels.push(newPanel)

                    dfd.resolve(response);

                }, function (errorResponse) {
                    console.log('error creating panel');
                    console.log(errorResponse);

                    gmapServices.hidePolygon(polygon);
                    polygon = null;

                    dfd.reject(errorResponse);
                });

            return dfd.promise;
        }

        function updatePanel(solar, panel) {
            var dfd = $q.defer();

            var panel = findPanelById(panel.id);
            var polygon = service.createPanelPolygon(drawingServices.overlayDataArray);

            var panelData = {
                'area': drawingServices.getAreaFormData(polygon)
            };

            solar.one('panels', panel.id).customPUT(panelData)
                .then(function (response) {
                    console.log('solar panel update response: ');
                    console.log(response);

                    gmapServices.showPolygon(polygon);

                    var newPanel = response.panel;
                    newPanel.polygon = polygon;
                    service.panels[panel.index] = newPanel;

                    dfd.resolve(response);

                }, function (err) {
                    console.log('solar panel update error response: ');
                    console.log(err);
                });

            return dfd.promise;
        }

        // id which is primary key in database
        function findPanelById (panelId) {
            var findPanel = null;

            service.panels.forEach(function(panel, index){
               if(panel.id == panelId) {
                   findPanel = panel;
                   findPanel.index = index;
                   return;
               }
            });
            return findPanel;
        }

        function onPanelClick (panel) {
            var panel = findPanelById(panel.id);

            if(panel) {
                if(service.lastSelectedPanel) {
                    gmapServices.resetPolygonFill(service.lastSelectedPanel);
                }

                if (panel.polygon) {
                    service.lastSelectedPanel = panel.polygon;
                    gmapServices.fillPolygon(service.lastSelectedPanel);
                    gmapServices.panToPolygon(panel.polygon);
                }

                // Remove Fill Polygon after 3 seconds
                $timeout(function () {
                    gmapServices.resetPolygonFill(service.lastSelectedPanel);
                }, 3000);
            }
        }

        function deletePanel(solar, panel) {
            var dfd = $q.defer();

            var panelId = panel.id;

            solar.deletePanel(panelId)
                .then(function (response) {

                    var panel = findPanelById(panelId);

                    gmapServices.hidePolygon(panel.polygon);
                    service.panels.splice(panel.index, 1);

                    dfd.resolve(response);
                }, function (errorResponse) {
                    dfd.reject(errorResponse);
                });
            return dfd.promise;
        }

        function clearSelectedPanel () {
            drawingServices.clearOverlay();
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('solarGmapServices', ['$rootScope', 'gmapServices', solarGmapServices]);

    function solarGmapServices($rootScope, gmapServices) {
        var service = {};

        service.solarMarkers = [];

        service.gmapService = gmapServices;

        service.initialize = initialize;
        service.initializeSolarMarkers = initializeSolarMarkers;
        service.showSolarMarkers = showSolarMarkers;
        service.hideSolarMarkers = hideSolarMarkers;
        service.findMarkerById = findMarkerById;
        service.openSolarInfoWindowById = openSolarInfoWindowById;
        service.resetZoom = resetZoom;

        service.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas');
        }

        function findMarkerById(solarId) {
            if (!service.solarMarkers.length) return;

            var solarMarker = null;

            service.solarMarkers.forEach(function (marker, key) {
                if(!marker.solar) return null;

                if (marker.solar.id == solarId) {
                    solarMarker = marker;
                    return false;
                }
            });
            return solarMarker;
        }

        function openSolarInfoWindowById(solarId) {
            var marker = service.findMarkerById(solarId);

            if(marker !== null) {
                google.maps.event.trigger(marker, 'click');
            }
        }

        function initializeSolarMarkers (solars) {
            if(solars == null || solars == 'undefined') {
                hideSolarMarkers();
                return;
            }

            // Close any infowindow
            gmapServices.closeAllInfoBox();

            //solars.forEach(function (solar, key) {
            //    if ('undefined' === typeof service.solarMarkers[key])
            //        service.solarMarkers[key] = [];
            //
            //    var marker = gmapServices.createCustomMarker(solar.coordinates);
            //    marker.infowindow = initInfowindow(solar);
            //    marker.solar = solar;
            //
            //    service.solarMarkers.push(marker);
            //
            //    gmapServices.addListener(marker, 'click', onClickSolarMarker);
            //});
            for (var i=0; i < service.solarMarkers.length || i < solars.length; i++) {
                var solar = solars[i];

                if (i >= service.solarMarkers.length) {
                    var marker = gmapServices.createCustomMarker(solar.coordinates);
                    marker.infowindow = initInfowindow(solar);
                    marker.solar = solar;
                    service.solarMarkers.push(marker);
                    gmapServices.addListener(marker, 'click', onClickSolarMarker);
                }
                else if (i >= solars.length) {
                    if (service.solarMarkers[i])
                        service.solarMarkers[i].solar = null;
                    gmapServices.hideMarker(service.solarMarkers[i]);
                }
                else if (service.solarMarkers[i]) {
                    service.solarMarkers[i].solar = solar;
                    service.solarMarkers[i].setPosition(solar.coordinates);
                    gmapServices.showMarker(service.solarMarkers[i]);
                }
            }
        }
        /* End of showSolarMarkers */


        function onClickSolarMarker () {
            gmapServices.openInfoBox(this.infowindow, this);
            gmapServices.panTo(this.getPosition());

            // Refresh variable
            //$rootScope.selectedSolar = null;

            // this refers to clicked marker
            $rootScope.selectedSolar = this.solar;
        }

        function showSolarMarkers () {
            if (!service.solarMarkers || service.solarMarkers.length <= 0) return;

            gmapServices.showMarkers(service.solarMarkers);
        }

        function hideSolarMarkers () {
            if(!service.solarMarkers || service.solarMarkers.length <= 0) return;

            gmapServices.hideMarkers(service.solarMarkers);

            // Close any infowindow
            gmapServices.closeAllInfoBox();
        }

        function resetZoom () {
            gmapServices.setZoomDefault();
        }

        function initInfowindow(solar) {
            var template = createInfowindowTemplate(solar);
            return gmapServices.createInfoBox(template);
        }

        function createInfowindowTemplate(solar) {
            return '<div class="marker_info none" id="marker_info">' +
                   '<div class="info" id="info">' +
                   '<h4>' + solar.project_name + '<span></span></h4>' +
                   '<span>' + solar.state + '</span>' +
                   '<a href="#!" class="infowindow_btn btn_view_solar_detail">More info</a>' +
                   '<span class="arrow"></span>' +
                   '</div>' +
                   '</div>';
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('screenshotServices', ['$rootScope', '$timeout', '$q','gmapServices', 'modalServices', 'utilServices', 'infoWindowServices', 'loaderServices', screenshotServices]);

    function screenshotServices ($rootScope, $timeout, $q, gmapServices, modalServices, utilServices, infoWindowServices, loaderServices) {
        var service = {};

        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.screenShotDrawingManager = null;
        service.screenshotDrawingListener = null;

        service.shapes = [];
        service.selectedShape = null;
        service.lineWidth = 1.0;

        var circleOptions = null;
        var polygonOptions = null;
        var polylineOptions = null;
        var rectangleOptions = null;

        $rootScope.hasScreenshotSelectedShape = false;

        var mapInitialTransform = '';

        var drawingListeners = {
            'deleteSelectedListener': null,
            'addTextBubbleListener': null,
            'startScreenshotListener': null
        };

        /**
         * Functions
         */
        service.startDrawing = startDrawing;
        service.endDrawing = endDrawing;
        service.onClickShape = onClickShape;
        service.selectShape = selectShape;
        service.selectLastShape = selectLastShape;
        service.deleteShapeAtIndex = deleteShapeAtIndex;
        service.deleteSelected = deleteSelected;

        service.solar = null;

        var screenshotCancelledListener = null;
        var mapClickListener = null;

        function startDrawing (solar, local) {
            service.solar = solar;
            // Copy of local to reference [solar, gmap_controller_scope]
            service.local = local;

            initDrawingManager();

            initScreenshotListeners();

            // Always Hide Modal if any
            modalServices.resolveHideModal();

            showScreenshotTools();
            watchShapeAtrributesValue();

            $(document).keyup(cancelScreenshotOnEsc);
        }

        function watchShapeAtrributesValue () {
            $rootScope.$watch('screenshotShapeStrokeColor', onChangeStrokeColor);

            $rootScope.$watch('screenshotShapeFillColor', onChangeFillColor);

            $rootScope.$watch('screenshotShapeStrokeWidth', onChangeStrokeWidth);

            drawingListeners.deleteSelectedListener = $rootScope.$on('delete-selected', deleteSelected);

            drawingListeners.addTextBubbleListener = $rootScope.$on('add-screenshot-text-bubble', addTextBubble);

            drawingListeners.startScreenshotListener = $rootScope.$on('start-screenshot', startScreenshot);
        }

        function startScreenshot() {
            if (!service.screenshotDrawingManager) {
                service.screenshotDrawingManager = gmapServices.createDrawingManager();
                gmapServices.showDrawingManager(service.screenshotDrawingManager);
            }

            if (!service.screenshotDrawingListener) {
                service.screenshotDrawingListener = gmapServices.addListener(
                    service.screenshotDrawingManager, 'overlaycomplete', onFinishScreenshot);
            }

            var setDragTool = {drawingMode: null};
            service.screenshotDrawingManager.setOptions(setDragTool);

            var drawOptions = {
                drawingMode: google.maps.drawing.OverlayType.RECTANGLE,
                drawingControl: false,
                rectangleOptions: {
                    fillOpacity: 0,
                    strokeOpacity: 0.9,
                    strokeColor: '#ffffff',
                    zIndex: 3
                }
            };
            service.screenshotDrawingManager.setOptions(drawOptions);
            hideScreenshotTools();

            /* Listen for ESC Key here to exit from capture screenshot mode */


        }

        function destroyListeners() {
            for (var key in drawingListeners) {
                if (drawingListeners.hasOwnProperty(key)) {
                    if (drawingListeners[key]) {
                        drawingListeners[key]();
                        drawingListeners[key] = null;
                    }
                }
            }
        }

        function stopScreenshot() {
            if (service.screenshotDrawingManager) {
                gmapServices.hideDrawingManager(service.screenshotDrawingManager);
                service.screenshotDrawingManager = null;
            }

            if (service.screenshotDrawingListener) {
                gmapServices.removeListener(service.screenshotDrawingListener);
                service.screenshotDrawingListener = null;
            }
        };

        function onFinishScreenshot (eArgs) {
            loaderServices.showLoader();
            stopScreenshot();

            var rectangle = eArgs.overlay;
            gmapServices.hidePolygon(rectangle);

            var bounds = rectangle.getBounds();
            var upperRight = gmapServices.fromLatLngToContainerPixel(bounds.getNorthEast());
            var lowerLeft = gmapServices.fromLatLngToContainerPixel(bounds.getSouthWest());
            var box = {
                x: lowerLeft.x,
                y: upperRight.y,
                width: upperRight.x - lowerLeft.x,
                height: lowerLeft.y - upperRight.y
            };

            convertMapTransformToLeftRight();

            $timeout(function () {
                html2canvas(document.getElementById('map-canvas'), {
                    "logging": true,
                    "imageTimeout": 120000,
                    "proxy": "/html2canvasproxy"
                }).then(function (canvas) {
                    loaderServices.hideLoader(true);

                    revertMapTransform();
                    initDrawingManager();

                    var tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = box.width;
                    tmpCanvas.height = box.height;

                    var context = tmpCanvas.getContext('2d');
                    context.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);

                    var toBlobFunction = function (blob) {
                        var file = blob;
                        var options = {
                            file: file,
                            caption: 'Screenshot'
                        };

                        modalServices.showScreenshotImageConfirmation(options)
                            .then(function (result) {
                                service.endDrawing();
                                var broadcast = $rootScope.$broadcast('screenshot-taken', file);
                                broadcast = null;
                                // endDrawing opens modal again
                            }, function () {
                                //
                            });
                    };

                    tmpCanvas.toBlob(toBlobFunction);
                });
            });
        }

        /**
         * Fix for screenshot when Google Map is scrolled or panned.
         * Thanks for answer from: http://stackoverflow.com/questions/24046778/html2canvas-does-not-work-with-google-maps-pan
         */
        function convertMapTransformToLeftRight() {
            mapInitialTransform = $(".gm-style>div:first>div").css("transform");
            var comp = mapInitialTransform.split(",") //split up the transform matrix
            var mapleft = parseFloat(comp[4]) //get left value
            var maptop = parseFloat(comp[5])  //get top value
            $(".gm-style>div:first>div").css({ //get the map container. not sure if stable
                "transform": "none",
                "left": mapleft,
                "top": maptop
            });
        };

        function revertMapTransform() {
            $(".gm-style>div:first>div").css({
                "transform": mapInitialTransform,
                left: 0,
                top: 0
            });
        }

        function addTextBubble () {
            if (!mapClickListener) {
                mapClickListener = gmapServices.addMapListener('click', function(e){
                    infoWindowServices.addInfoWindow(e.latLng);
                    cancelAddTextBubble();
                });
                gmapServices.setMapCursorCrosshair();
            }

            if (service.screenshotDrawingManager) {
                var setDragTool = {drawingMode: null};
                service.screenshotDrawingManager.setOptions(setDragTool);
            }
        }

        function cancelAddTextBubble() {
            if (mapClickListener) {
                gmapServices.setMapCursorDefault();
                gmapServices.removeListener(mapClickListener);
                mapClickListener = null;
            }
        }

        function onChangeFillColor() {
            var color = $rootScope.screenshotShapeFillColor;
            if(!color) return;

            var rgba = /rgba\(([0-9\.]+),([0-9\.]+),([0-9\.]+),([0-9\.]+)\)/.exec(color);
            var colorHexString = '#'
                + utilServices.byteToHex(parseFloat(rgba[1]))
                + utilServices.byteToHex(parseFloat(rgba[2]))
                + utilServices.byteToHex(parseFloat(rgba[3]));

            circleOptions = setDrawingOption('circleOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polygonOptions = setDrawingOption('polygonOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polylineOptions = setDrawingOption('polylineOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);

            updateSelectedShape();
        }

        function onChangeStrokeColor () {
            var color = $rootScope.screenshotShapeStrokeColor;
            if (!color) return;

            var rgba = /rgba\(([0-9\.]+),([0-9\.]+),([0-9\.]+),([0-9\.]+)\)/.exec(color);
            var colorHexString = '#'
                + utilServices.byteToHex(parseFloat(rgba[1]))
                + utilServices.byteToHex(parseFloat(rgba[2]))
                + utilServices.byteToHex(parseFloat(rgba[3]));

            circleOptions = setDrawingOption('circleOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polygonOptions = setDrawingOption('polygonOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polylineOptions = setDrawingOption('polylineOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);

            updateSelectedShape();
        }

        function onChangeStrokeWidth () {
            var lineWidth = $rootScope.screenshotShapeStrokeWidth;

            $timeout(function () {
                service.lineWidth = lineWidth;
            });

            circleOptions = setDrawingOption('circleOptions', ['strokeWeight'], [lineWidth]);
            polygonOptions = setDrawingOption('polygonOptions', ['strokeWeight'], [lineWidth]);
            polylineOptions = setDrawingOption('polylineOptions', ['strokeWeight'], [lineWidth]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['strokeWeight'], [lineWidth]);

            updateSelectedShape();
        }

        function initScreenshotListeners() {
            if( !screenshotCancelledListener) {
                screenshotCancelledListener = $rootScope.$on('screenshot-cancelled', service.endDrawing);
            }
        }

        function showScreenshotTools () {
            // Show Map Cancel button
            $rootScope.showScreenshotButtons = true;
        }

        function initDrawingManager() {
            if (service.drawingManager) {
                // Reinitialize Drawing Listener
                initDrawingListener();
                console.log('Reinitialize Drawing Listener on Screenshot Services');
                return;
            }

            service.drawingManager = gmapServices.createDrawingToolsManager();
            gmapServices.showDrawingManager(service.drawingManager);

            initDrawingListener();
        }

        function initDrawingListener() {
            if (gmapServices.apiAvailable()) {
                if ( !service.drawingCompleteListener) {
                    service.drawingCompleteListener = gmapServices.addListener(
                        service.drawingManager, 'overlaycomplete', overlayCompleteListener);
                }

                $timeout(function () {
                    showScreenshotTools();
                });
            }
        }

        function overlayCompleteListener(eventArgs) {
            var object = {
                shape: eventArgs.overlay,
                type: eventArgs.type,
                listener: gmapServices.addListener(
                    eventArgs.overlay, 'click', service.onClickShape
                )
            }
            service.shapes.push(object);
            service.selectLastShape();
        }

        function onClickShape() {
            var index = _.findIndex(service.shapes, {shape: this})
            if (index >= 0) service.selectShape(service.shapes[index]);
        }

        function selectShape(shape) {
            if (service.selectedShape) {
                service.selectedShape.shape.setDraggable(false);
                if (service.selectedShape.type != google.maps.drawing.OverlayType.MARKER)
                    service.selectedShape.shape.setEditable(false);
            }

            var _shape = shape;
            $timeout(function () {
                service.selectedShape = _shape;
                if (service.selectedShape && service.selectedShape.shape) {
                    service.selectedShape.shape.setDraggable(true);
                    if (service.selectedShape.type != google.maps.drawing.OverlayType.MARKER)
                        service.selectedShape.shape.setEditable(true);

                    $rootScope.hasScreenshotSelectedShape = true;
                }
                ;
            });
        }

        function selectLastShape () {
            if (service.shapes.length > 0) {
                service.selectShape(service.shapes[service.shapes.length - 1]);
            } else {
                service.selectShape(null);
            }
        }

        function deleteSelected () {
            if (service.selectedShape) {
                deleteShapeAtIndex(_.indexOf(service.shapes, service.selectedShape));

                if(service.shapes.length <= 0) {
                    $rootScope.hasScreenshotSelectedShape = false;
                }
            }
        }

        function deleteShapeAtIndex(index) {
            if (index >= 0) {
                var object = service.shapes[index];
                service.shapes.splice(index, 1);
                gmapServices.removeListener(object.listener);
                gmapServices.hidePolygon(object.shape);
                delete object.shape;
                delete object.listener;
                service.selectedShape = null;
                service.selectLastShape();
            }
        }

        function endDrawing () {
            while (service.shapes.length > 0)
                service.deleteShapeAtIndex(service.shapes.length - 1);

            infoWindowServices.clearInfoWindows();
            hideScreenshotTools();
            destroyDrawingManager();
            
            //modalServices.showModal();
            // or
            var solar = service.local[0],
                dialog = service.local[1].showSolarDetailInfowindow;


            dialog(solar);

            console.log('endDrawing is called');

            console.log('scope local trigger destroy: ');
            console.log(service.local[2]);
            service.local[2].$destroy();
            service.local[2] = null;

            $rootScope.solarDetailSelectedTab = 2;
        }

        function hideScreenshotTools () {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
                service.drawingManager = null;
            }

            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            cancelAddTextBubble();

            $rootScope.showScreenshotButtons = false;
            $rootScope.showStrokeWidth = false;
        }

        function setDrawingOption(optionName, propertyNames, values) {
            if (service.drawingManager) {
                var options = service.drawingManager.get(optionName);
                if (options) {
                    for (var i = 0; i < propertyNames.length && i < values.length; i++) {
                        var propertyName = propertyNames[i];
                        var value = values[i];
                        if (options.hasOwnProperty(propertyName)) {
                            options[propertyName] = value;
                        }
                    }
                    service.drawingManager.set(optionName, options);
                    return options;
                }
            }
            return null;
        }

        function updateSelectedShape() {
            if (!service.selectedShape) return;

            if (service.selectedShape.type == google.maps.drawing.OverlayType.MARKER) {

            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.POLYLINE) {
                service.selectedShape.shape.setOptions(polylineOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.CIRCLE) {
                service.selectedShape.shape.setOptions(circleOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.POLYGON) {
                service.selectedShape.shape.setOptions(polygonOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.RECTANGLE) {
                service.selectedShape.shape.setOptions(rectangleOptions);
            }
        }

        function destroyDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
                service.drawingManager = null;
            }

            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            if (screenshotCancelledListener) {
                screenshotCancelledListener();
                screenshotCancelledListener = null;
            }

            destroyListeners();
        }

        function cancelScreenshotOnEsc(e) {
            // on press ESC cancel taking screenshot
            if (e.keyCode == 27) {
                loaderServices.hideLoader();
                endDrawing();
            }
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('modalServices', ['$rootScope', '$q', '$mdDialog', '$mdMedia', 'Solars', modalServices]);

    function modalServices($rootScope, $q, $mdDialog, $mdMedia, Solars) {

            var service = {};

            service.customFullscreen = $mdMedia('xs') || $mdMedia('sm');

            service.solarAddModal = null;
            service.showUpdateModal = null;
            service.showUploadSolarFileModal = null;
            service.showScreenshotImageConfirmationModal = null;
            service.previewImageModal = null;

            /* Service Functions */
            service.showAddSolar = showAddSolar;
            service.showUpdateSolar = showUpdateSolar;
            service.showUploadSolarFile = showUploadSolarFile;
            service.hideModalWithReponse = hideModalWithReponse;
            service.showScreenshotImageConfirmation = showScreenshotImageConfirmation;
            service.previewImage = previewImage;
            service.showUpdateSolarPanelDetails = showUpdateSolarPanelDetails;
            service.closeModal = closeModal;
            service.hideModal = hideModal;
            service.showModal = showModal;
            service.resolveHideModal = resolveHideModal;


            function showAddSolar(ev) {
                var deferred = $q.defer();

                if (service.solarAddModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    service.solarAddModal = $mdDialog.show({
                        controller: 'addSolarController',
                        controllerAs: 'addSolarCtl',
                        templateUrl: '/solar/add',
                        parent: angular.element(document.querySelector('#solar-container')),
                        targetEvent: ev,
                        hasBackdrop: false,
                        fullscreen: service.customFullscreen,
                        onComplete: function (scope, element, options) {
                            //$('.md-dialog-container').addClass('flex-50');
                            //$('.md-dialog-container').addClass('display-left-md-dialog-container');
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.solarAddModal.then(function (result) {
                        service.solarAddModal = null;
                        deferred.resolve(result);

                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");

                        service.solarAddModal = null;
                        deferred.reject(reason);
                    });
                }

                return deferred.promise;
            }


            function showUpdateSolar(_solar, callerScope, event) {
                var deferred = $q.defer();

                console.log(event);

                if (service.showUpdateModal) {
                    service.showUpdateModal = null;
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    var openModal = function(solarData) {
                        service.showUpdateModal = $mdDialog.show({
                            controller: 'updateSolarController',
                            controllerAs: 'updateSolarCtl',
                            templateUrl: '/solar/edit',
                            parent: angular.element(document.querySelector('#solar-container')),
                            targetEvent: event,
                            hasBackdrop: false,
                            locals: {local: [_solar, callerScope]},
                            fullscreen: service.customFullscreen,
                            resolve: {
                                solar: function () {
                                    return angular.copy(solarData);
                                }
                            },
                            onComplete: function (scope, element, options) {
                                $('.md-scroll-mask').css('z-index', '0');
                            }
                        });
                        service.showUpdateModal.then(function (result) {
                            service.showUpdateModal = null;
                            deferred.resolve(result);
                        }, function (reason) {
                            $rootScope.$broadcast("modal-dismissed");
                            service.showUpdateModal = null;
                            deferred.reject(reason);
                        });
                    };

                    // load Solar details before opening modal
                    var onGetSolarSucceed = function (result) {
                        console.log('on get solar succeed result: ');
                        console.log(result);
                        openModal(result);
                    };
                    var onGetSolarFail = function (result) {
                        if (result.status == 0 || result.status == 502) {
                            deferred.reject(result);
                        }
                    };

                    Solars.get(_solar.id).then(onGetSolarSucceed, onGetSolarFail);
                }
                return deferred.promise;
            }


            function showUploadSolarFile (solarFile, solarModel) {
                var deferred = $q.defer();

                if (service.showUploadSolarFileModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    service.showUploadSolarFileModal = $mdDialog.show({
                        controller: 'uploadSolarFileController',
                        controllerAs: 'uploadSolarFileCtl',
                        templateUrl: '/solar/upload',
                        parent: angular.element(document.body),
                        fullscreen: service.customFullscreen,
                        hasBackdrop: false,
                        resolve: {
                            solar: function () {
                                return angular.copy(solarModel);
                            },
                            file: function () {
                                return angular.copy(solarFile)
                            }
                        },
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.showUploadSolarFileModal.then(function (result) {
                        service.showUploadSolarFileModal = null;
                        deferred.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        service.showUploadSolarFileModal = null;
                        deferred.reject(reason);
                    });
                }
                return deferred.promise;
            }

            function showScreenshotImageConfirmation (model) {
                console.log('showScreenshotImageConfirmation called');
                var deferred = $q.defer();
                if (service.showScreenshotImageConfirmationModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    service.showScreenshotImageConfirmationModal = $mdDialog.show({
                        controller: 'screenshotImageConfirmController',
                        controllerAs: 'screenshotImageConfirmCtl',
                        templateUrl: '/image/screenshot/confirm',
                        parent: angular.element(document.body),
                        hasBackdrop: false,
                        fullscreen: service.customFullscreen,
                        resolve: {
                            imagePreview: function () {
                                return model;
                            }
                        },
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.showScreenshotImageConfirmationModal.then( function(result) {
                        console.log('show screenshot modal save');
                        service.showScreenshotImageConfirmationModal = null;

                        deferred.resolve(result);
                    }, function (reason) {
                        console.log('show screenshot modal canceled');
                        service.showScreenshotImageConfirmationModal = null;
                        deferred.reject(reason);
                    });
                }

                return deferred.promise;
            }

            function previewImage(event, photo, _locals) {
                var deferred = $q.defer();
                if (service.previewImageModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    service.previewImageModal = $mdDialog.show({
                        controller: 'previewImageController',
                        controllerAs: 'previewImageCtl',
                        templateUrl: '/image/preview',
                        parent: angular.element(document.body),
                        hasBackdrop: false,
                        targetEvent: event,
                        fullscreen: service.customFullscreen,
                        clickOutsideToClose: true,
                        resolve: {
                            photo: function () {
                                return photo;
                            }
                        },
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.previewImageModal.then(function (result) {
                        console.log('show screenshot modal save');
                        service.previewImageModal = null;
                        deferred.resolve(result);
                    }, function (reason) {
                        console.log('show screenshot modal canceled');
                        service.previewImageModal = null;
                        deferred.reject(reason);
                    });
                }

                return deferred.promise;
            }

            function showUpdateSolarPanelDetails (event, solar, panel) {
                var dfd = $q.defer();

                if (service.showUpdateSolarPanelModal) {
                    // prevent multiple modals from being opened
                    dfd.reject("Modal already opened");
                } else {
                    service.showUpdateSolarPanelModal = $mdDialog.show({
                        controller: 'updateSolarPanelController',
                        controllerAs: 'ctl',
                        templateUrl: '/solar/panel/edit',
                        parent: angular.element(document.body),
                        hasBackdrop: false,
                        targetEvent: event,
                        autoWrap: false,
                        fullscreen: service.customFullscreen,
                        locals: {'solar': solar, 'panel': panel},
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.showUpdateSolarPanelModal.then(function (result) {
                        console.log('show update solar panel modal save');
                        service.showUpdateSolarPanelModal = null;
                        dfd.resolve(result);
                    }, function (reason) {
                        console.log('show update solar panel modal canceled');
                        service.showUpdateSolarPanelModal = null;
                        dfd.reject(reason);
                    });
                }

                return dfd.promise;
            }

            function hideModalWithReponse(data) {
                $mdDialog.hide(data);
            }

            // Temporarily Hide Infowindow
            function hideModal() {
                $('.md-dialog-container').css('display', 'none');
            }

            function showModal() {
                $('.md-dialog-container').css('display', 'flex');
            }

            function resolveHideModal() {
                $mdDialog.hide();
            }

            // Close Modal
            function closeModal() {
              $mdDialog.cancel();
            }

            return service;
     }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('locationServices', ['$q', 'gmapServices', locationServices]);

    function locationServices($q, gmapServices) {
        var service = {};

        service.getCurrentLocation = function () {
            if(!navigator.geolocation) {
                console.log('Browser doesnt support Geolocation');
                return false;
            }
            var defer = $q.defer();

            navigator.geolocation.getCurrentPosition(function(position) {
               defer.resolve(position);
            });

            return defer.promise;
        };

        // Parameter must be a latLng
        service.showCurrentLocation = function (position) {
            var latLng = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            var marker = gmapServices.showCurrentLocation(latLng);
            var offset = 0.002;


            gmapServices.panToOffsetLeft(latLng, offset);
            gmapServices.setZoomInDefault();

            return marker;
        };

        service.showDraggableLocation = function () {
            var draggable = true,
                latLng = gmapServices.map.getCenter();

            var marker = gmapServices.showCurrentLocation(latLng, draggable);

            //gmapServices.panToOffsetLeft(latLng);

            return marker;
        };

        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('infoWindowServices', ['gmapServices', infoWindowServices]);

    function infoWindowServices (gmapServices) {
        var service = {};

        var uniqueId = 0;
        var openList = [];
        var closeList = [];

        service.addInfoWindow = addInfoWindow;
        service.clearInfoWindows = clearInfoWindows;

        function addInfoWindow(position) {
            var infoWindow = gmapServices.createCanvasInfoWindow();
            infoWindow.uniqueId = uniqueId++;
            infoWindow.setPosition(position);
            infoWindow.open();
            openList.push(infoWindow);
        }

        function clearInfoWindows() {
            while (openList.length > 0) {
                var infoWindow = openList[openList.length - 1];
                openList.splice(openList.length - 1, 1);
                gmapServices.hideCanvasInfoWindow(infoWindow);
                closeList.push(infoWindow);
            }
        }

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('solarApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        var MapTypeId = {
            USGSTopo: "USGS Topo"
        };

        service.MARKER_ICONS = {
            // IN-PROCESS
            RED: '/resources/images/red-dot.png',
            // SUBMITTED
            YELLOW: '/resources/images/yellow-dot.png',
            // APPROVED
            GREEN: '/resources/images/green-dot.png',
            // INVALID
            ERROR: '/resources/images/caution.png'
        };

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(32.7577, -88.4376);

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.WMSGetTopoUrl = WMSGetTopoUrl;
        service.createWMSTopoMapType = createWMSTopoMapType;


        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.LEFT_TOP,
                    mapTypeIds: [google.maps.MapTypeId.HYBRID, google.maps.MapTypeId.SATELLITE, MapTypeId.USGSTopo]
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            $(myMapId).height($(window).height() - (42));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            var overlayView = new google.maps.OverlayView();
            overlayView.draw = function () {
            };
            overlayView.setMap(service.map);
            service.overlayView = overlayView;

            // Initialize USGS TOPO Map Layer
            service.createWMSTopoMapType();

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-solar-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyMarker(marker) {
            service.hideMarker(marker);
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
                //service.map.setZoom(service.defaultZoom);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach( function(path){
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function createPolyline(path) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 5,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        /**
         * Start of TOPOGRAPHY Map Code
         */

        /*The code that reads in the WMS file.  To change the WMS layer the user would update the layers line.  As this is constructed now you need to have this code for each WMS layer.
         Check with your Web Map Server to see what are the required components of the address.  You may need to add a couple of segements.  For example, the ArcServer WMS requires
         a CRS value which is tacked on to the end of the url.  For an example visit http://www.gisdoctor.com/v3/arcserver_wms.html
         */

         function WMSGetTopoUrl(tile, zoom) {
            var projection = service.map.getProjection();
            var zpow = Math.pow(2, zoom);
            var ul = new google.maps.Point(tile.x * 256.0 / zpow, (tile.y + 1) * 256.0 / zpow);
            var lr = new google.maps.Point((tile.x + 1) * 256.0 / zpow, (tile.y) * 256.0 / zpow);
            var ulw = projection.fromPointToLatLng(ul);
            var lrw = projection.fromPointToLatLng(lr);
            //The user will enter the address to the public WMS layer here.  The data must be in WGS84
            var baseURL = "http://basemap.nationalmap.gov/arcgis/services/USGSTopo/MapServer/WMSServer?&REQUEST=GetMap&SERVICE=WMS&VERSION=1.3&LAYERS="; //begining of the WMS URL ending with a "?" or a "&".
            var format = "image%2Fjpeg"; //type of image returned  or image/jpeg
            //The layer ID.  Can be found when using the layers properties tool in ArcMap
            var layers = "0";
            var srs = "EPSG:4326"; //projection to display. This is the projection of google map. Don't change unless you know what you are doing.
            var bbox = ulw.lat() + "," + ulw.lng() + "," + lrw.lat() + "," + lrw.lng();
            //Add the components of the URL together
            var url = baseURL + layers + "&Styles=default" + "&SRS=" + srs + "&BBOX=" + bbox + "&width=256" + "&height=256" + "&format=" + format + "&BGCOLOR=0xFFFFFF&TRANSPARENT=true" + "&reaspect=false" + "&CRS=EPSG:4326";
            return url;
        }

        function createWMSTopoMapType() {
            if (!service.apiAvailable()) return null;
            // Creating the WMS layer options.  This code creates the Google imagemaptype options for each wms layer.
            // In the options the function that calls the individual wms layer is set.
            var wmsOptions = {
                alt: MapTypeId.USGSTopo,
                getTileUrl: service.WMSGetTopoUrl,
                isPng: false,
                maxZoom: 16,
                minZoom: 1,
                name: MapTypeId.USGSTopo,
                tileSize: new google.maps.Size(256, 256),
                credit: 'USGS'
            };

            // init the USGS Topo map type
            var wmsMapType = new google.maps.ImageMapType(wmsOptions);
            service.map.mapTypes.set(MapTypeId.USGSTopo, wmsMapType);
        }

        return service;
    }
}());


(function(){
'use strict';
//TODO error handler to display in angular material way coming from flask response
angular.module('solarApp')
    .factory('errorServices', [errorServices]);
    
    function errorServices() {
        var service = {};
        
        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('drawingServices', ['gmapServices', 'modalServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, modalServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.cancelDrawingMode = cancelDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                // Reinitialize Drawing Listener
                service.initDrawingListener();
                console.log('Reinitialize Drawing Listener');
                return;
            }

            console.log('init drawing manager');

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);

            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
            console.log('added drawing complete listener');
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if(service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();

                console.log('shape changed');
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            service.overlayStrokeColor = strokeColor || '';

            // Show Map Cancel button
            $rootScope.showMapCancelBtn = true;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);

            // Always Hide Modal if any
            modalServices.hideModal();

            console.log('start drawing mode');
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            //show this modal again once drawing mode is off
            modalServices.showModal();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if( !service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if(!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            //switch (service.overlayType) {
            //    case google.maps.drawing.OverlayType.POLYGON:
            return getPolygonCoords(_area);
            //        break;
            //    case google.maps.drawing.OverlayType.RECTANGLE:
            //        data = service.getRectangleCoords();
            //}
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());

(function () {
'use strict';

angular.module('solarApp')
    .factory('alertServices', ['SweetAlert', '$mdToast', alertServices]);

    function alertServices(SweetAlert, $mdToast) {
        var service = {};

        service.showWarningDrawSiteArea = showWarningDrawSiteArea;
        service.showInvalidDataMessages = showInvalidDataMessages;
        service.showWarningDrawSolarPanelArea = showWarningDrawSolarPanelArea;
        service.showInvalidFileUpload = showInvalidFileUpload;
        service.showFileUploadSuccess = showFileUploadSuccess;

        function showWarningDrawSiteArea () {
            SweetAlert.swal({
                title: 'Please draw site area.',
                type: 'warning'
            });
        }

        function showWarningDrawSolarPanelArea() {
            SweetAlert.swal({
                title: 'Please Draw Solar Panel area.',
                type: 'warning'
            });
        }

        function showInvalidFileUpload () {
            SweetAlert.swal({
                title: 'Invalid File Uploaded.',
                type: 'error'
            });
        }

        function showFileUploadSuccess () {
            $mdToast.show(
                $mdToast.simple()
                    .textContent('File Successfully Uploaded.')
                    .position('top right')
                    .hideDelay(3000)
            );
        }

        function showInvalidDataMessages (errorStr) {
            SweetAlert.swal({
                title: 'Invalid Data',
                text: errorStr,
                type: 'error',
                confirmButtonText: 'Close'
            });
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .directive('fixed', ['$compile', '$window', fixed]);

    function fixed($compile, $window) {
        console.log('fixed called');
        function postLink(scope, element, attrs) {
            var table = copyAttrs(jQLite('<table>'), element.parent());
            var clone = element.clone().removeAttr('fixed').removeAttr('ng-if');

            table.css({
                'position': 'absolute',
                'backgroundColor': '#fff',
                'zIndex': 1
            }).addClass('fixed');

            element.css('visibility', 'hidden');

            grandParent().prepend($compile(table.append(clone))(scope));

            var height = clone.prop('clientHeight');

            grandParent().css('position', 'relative').on('scroll', function () {
                if (grandParent().prop('scrollTop') === 0) {
                    table.removeClass('md-whiteframe-1dp');
                } else if (!table.hasClass('md-whiteframe-1dp')) {
                    table.addClass('md-whiteframe-1dp');
                }
                clone.children().css('height', grandParent().prop('scrollTop') + height + 'px');
            });

            function cells() {
                return clone.prop('rows')[0].cells.length;
            }

            function copyAttrs(newElement, oldElement) {
                var attrs = oldElement.prop('attributes');

                for (var attr in attrs) {
                    newElement.attr(attrs[attr].name, attrs[attr].value);
                }

                return newElement;
            }

            function getCells(row) {
                return Array.prototype.filter.call(row.cells, function (cell) {
                    return !cell.classList.contains('ng-leave');
                });
            }

            function grandParent() {
                return element.parent().parent();
            }

            function jQLite(node) {
                return angular.element(node);
            }

            function update() {
                getCells(clone.prop('rows')[0]).map(jQLite).forEach(function (copy, index) {
                    if (copy.hasClass('clone')) {
                        return;
                    }

                    copy.addClass('clone');

                    var cell = element.find('th').eq(index);
                    var style = $window.getComputedStyle(cell[0]);

                    copy.css('paddingBottom', (height / 2) - (cell.children().prop('clientHeight') / 2) + 'px');

                    var getWidth = function () {
                        return style.width;
                    };

                    var setWidth = function () {
                        copy.css('minWidth', style.width);
                    };

                    var listener = scope.$watch(getWidth, setWidth);

                    $window.addEventListener('resize', setWidth);

                    copy.on('$destroy', function () {
                        listener();
                        $window.removeEventListener('resize', setWidth);
                    });

                    cell.on('$destroy', function () {
                        copy.remove();
                    });
                });
            }

            scope.$watch(cells, update);

            element.on('$destroy', function () {
                table.remove();
            });
        }

        return {
            link: postLink
        };
    }
}());





(function(){
'use strict';

angular.module('solarApp')
    .controller('uploadSolarFileController', ['$rootScope', 'modalServices', 'solar', 'file', uploadSolarFileController]);

    function uploadSolarFileController ($rootScope, modalServices, solar, file) {
        var vm = this;

        vm.initialize = initialize;
        vm.closeModal = closeModal;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            console.log('upload solar file controller initialized!');

            console.log('solar: ');
            console.log(solar);

            console.log('file: ');
            console.log(file);
        }

        function closeModal() {
            modalServices.closeModal();
            //$rootScope.$broadcast('show-solar-detail');
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('updateSolarPanelController', ['solar', 'panel', 'modalServices', updateSolarPanelController]);

    function updateSolarPanelController (solar, panel, modalServices) {
        var vm = this;

        vm.initialize = initialize;
        vm.updatePanel = updatePanel;
        vm.closeModal = closeModal;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.solar = solar;
            vm.panel = panel;
            vm.paneldata = angular.copy(panel);

            console.log('update solar panel controller intialized!');
        }

        function updatePanel() {
            solar.one('panels', vm.paneldata.id).customPUT(vm.paneldata)
                .then(function (response) {
                    modalServices.hideModalWithReponse(response);
                }, function (err) {
                    console.log('solar panel update error response: ');
                    console.log(err);
                });
        }

        function closeModal () {
            modalServices.closeModal();
        }
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('updateSolarController', ['$log', '$rootScope', '$scope', '$q', 'solar', 'SOLAR_STATUSES', 'usStates', 'modalServices', 'locationServices', 'gmapServices', 'drawingServices', 'alertServices', 'screenshotServices', 'uploadServices', 'solarPanelServices', 'local', updateSolarController]);

    function updateSolarController($log, $rootScope, $scope, $q, solar, SOLAR_STATUSES, usStates, modalServices, locationServices, gmapServices, drawingServices, alertServices, screenshotServices, uploadServices, solarPanelServices, local) {
        var vm = this;


        $scope.selectedTab = 0;
        /*
         Represents the SOLAR Model
         TODO: Need to change it to Backbone Model or Breeze
         */

        vm.solar = {
            id: 0,
            panels: []
        };

        vm.currentMarker = null;
        vm.areaPolygon = null;
        vm.local = null;

        /* Drawing Listeners Container */
        var areaListeners = {
            'saveAreaListener': null,
            'cancelListener': null,
            'deleteSelectedListener': null
        };

        /* Drawing Listeners for Panel */
        var panelListeners = {
          'savePanelAreaListener': null,
          'cancelPanelListener': null,
          'deleteSelectedPanelListener': null
        };

        var editPanelListeners = {
            'savePanelAreaListener': null,
            'cancelPanelListener': null,
            'deleteSelectedPanelListener': null
        };

        var screenshotTakenListener = null;
        var screenshotPhotoUploadedListener = null;

        var changePhotoFromScreenshotListener = null;
        var screenshotPhotoUpdateListener = null;

        /* Scope Functions here */
        vm.initialize = initialize;
        vm.updateSolar = updateSolar;
        vm.closeModal = closeModal;

        vm.initialize();

        /* General Info Tab Functions */
        vm.getCurrentLocation = getCurrentLocation;
        vm.pointCurrentLocation = pointCurrentLocation;
        vm.startDrawSite = startDrawSite;
        vm.stopDrawingMode = stopDrawingMode;

        /* Solar Panels Tab Functions */
        vm.addSolarPanel = addSolarPanel;
        vm.deleteSolarPanel = deleteSolarPanel;
        vm.onPanelItemClick = onPanelItemClick;
        vm.editSolarPanelShape = editSolarPanelShape;
        vm.editSolarPanelDetails = editSolarPanelDetails;

        /* Photos Tab Model */
        vm.uploadSolarPhotoModel = null;
        vm.uploadSolarPhotoErrorModel = null;

        /* Photos Tab Functions */
        vm.uploadSolarPhoto = uploadSolarPhoto;
        vm.openPhotoMenu = openPhotoMenu;
        vm.updateSolarPhoto = updateSolarPhoto;
        vm.deletePhoto = deletePhoto;
        vm.editSolarPhotoCaption = editSolarPhotoCaption;
        vm.initializeScreenshot = initializeScreenshot;
        vm.changePhotoFromScreenshot = changePhotoFromScreenshot;
        vm.previewImage = previewImage;


        /* Functions here */

        /* Scope Functions */
        function initialize () {
            vm.states = usStates;
            vm.statuses = SOLAR_STATUSES;

            $rootScope.local = angular.copy(local);
            $rootScope.local.push($scope);

            vm.local = local;
            vm.local.push($scope);

            // Close any infobox
            gmapServices.closeAllInfoBox();

            $scope.$watch(angular.bind(vm, function() {
                return vm.solar;
            }), function (){
                initializeSolar();
                initializeSolarPanels();
            });

            $rootScope.$watch('solarDetailSelectedTab', function(newValue, oldValue){
                $scope.selectedTab = newValue;
            });

            vm.solar = solar;

            $scope.$watch(angular.bind(vm, function () {
                if (vm.currentMarker) {
                    return vm.currentMarker.getPosition();
                }
            }), currentLocationChanged);

            $rootScope.$on('overlay-complete', function () {
                $rootScope.$apply(function () {
                    $rootScope.showSaveAreaBtn = true;
                    $rootScope.showDeleteSelectedBtn = true;
                });
            });

            screenshotPhotoUploadedListener = $rootScope.$on('solar-screenshot-photo-uploaded', function(event, photo) {
               console.log('listen from solar-screenshot-photo-uploaded event!');
               vm.solar.photos.push(photo);
            });

            screenshotPhotoUpdateListener = $rootScope.$on('solar-screenshot-photo-updated', function (event, photo, index) {
                console.log('listen from solar-screenshot-photo-updated event!');
                vm.solar.photos[index] = photo;
            });

            //if( !screenshotTakenListener) {
            //    screenshotTakenListener = $rootScope.$on('screenshot-taken', uploadScreenshotPhoto);
            //}

            $scope.$on('$destroy', function () {
                cleanUp();
            });
        }


        function updateSolar () {
            if (vm.areaPolygon) {
                vm.solar.area = drawingServices.getAreaFormData(vm.areaPolygon);
            }

            postToServer()
                .then( function(response) {
                    modalServices.hideModalWithReponse(response.solar);

                }, function(errorResponse) {
                    // TODO find a way to display error and fixed circular json issue
                    //console.log(errorResponse);
                    //var errorStr = JSON.stringify(errorResponse.data.errors);
                    alertServices.showInvalidDataMessages('Theres a problem processing your data.');

                });
        }

        function closeModal() {
            modalServices.closeModal();
        }

        /* General Info Tab Functions */

        function getCurrentLocation () {
            locationServices.getCurrentLocation()
                .then(function (position) {
                    // Clear current marker to
                    // display only one current marker
                    clearCurrentMarker();

                    // a watch triggers geocoding on the currentMarker
                    vm.currentMarker = locationServices.showCurrentLocation(position);
                });
        }

        function pointCurrentLocation() {
            // Clear current marker to
            // display only one current marker
            clearCurrentMarker();

            vm.currentMarker = locationServices.showDraggableLocation();

            gmapServices.addListener(vm.currentMarker, 'dragend', function (val) {
                $scope.$apply();
            });
        }

        function startDrawSite() {
            hideAreaPolygon();

            drawingServices.startDrawingMode();

            areaListeners.saveAreaListener = $scope.$on('save-area', saveArea);
            areaListeners.cancelListener = $scope.$on('cancel-drawing', cancelDrawing);
            areaListeners.deleteSelectedListener = $scope.$on('delete-selected', deleteSelected);
        }


        function stopDrawingMode() {
            drawingServices.stopDrawingMode();
            hideDrawingButtons();

            for (var key in areaListeners) {
                if (areaListeners.hasOwnProperty(key)) {
                    if (areaListeners[key]) {
                        areaListeners[key]();
                        areaListeners[key] = null;
                    }
                }
            }
            console.log('area listeners cleared');
        }

        /* End General Info Tab Functions */


        /* Solar Panel Tab Functions */

        function editSolarPanelDetails (event, panel, index) {
            var solar = $rootScope.local[0],
                dialog = $rootScope.local[1].showSolarDetailInfowindow;

            modalServices.showUpdateSolarPanelDetails(event, vm.solar, panel)
                .then( function(response){
                    console.log(response);
                    solar.panels[index] = response.panel;
                }, function (err) {
                    console.log(err);
                })
                .finally( function(){
                    dialog(solar);
                    $rootScope.solarDetailSelectedTab = 1;
                });
        }

        function editSolarPanelShape (panel, index) {

            solarPanelServices.initializeDrawPanel();
            // Hide Panel when editing
            solarPanelServices.hidePanelById(panel.id);

            editPanelListeners.savePanelAreaListener = $scope.$on('save-area', function(){
                if (!drawingServices.overlayDataArray.length) {
                    alertServices.showWarningDrawSolarPanelArea();
                    return;
                }
                solarPanelServices.updatePanel(vm.solar, panel)
                    .then(function (response) {
                        // update panel area from vm.solar.panels
                        vm.solar.panels[index] = response.panel;
                    }, function (errorResponse) {
                        console.log('error creating panel');
                        console.log(errorResponse);
                    });

                stopPanelDrawingMode();
            });

            editPanelListeners.cancelPanelListener = $scope.$on('cancel-drawing', function(){
                // show old panel
                solarPanelServices.showPanelById(panel.id);

                drawingServices.stopDrawingMode();
                hideDrawingButtons();

                for (var key in editPanelListeners) {
                    if (editPanelListeners.hasOwnProperty(key)) {
                        if (editPanelListeners[key]) {
                            editPanelListeners[key]();
                            editPanelListeners[key] = null;
                        }
                    }
                }
            });

            editPanelListeners.deleteSelectedPanelListener = $scope.$on('delete-selected', function () {
                console.log('delete selected edit panel is called');
                solarPanelServices.clearSelectedPanel();
                $rootScope.showDeleteSelectedBtn = false;
            });
        }


        function addSolarPanel () {
            // dismiss update modal
            // maintain of displaying the areaPolygon
            // enable drawing mode
            // show drawing controls
            // start draw panel
            solarPanelServices.initializeDrawPanel();

            panelListeners.savePanelAreaListener = $scope.$on('save-area', savePanelArea);
            panelListeners.cancelPanelListener = $scope.$on('cancel-drawing', stopPanelDrawingMode);
            panelListeners.deleteSelectedPanelListener = $scope.$on('delete-selected', deleteSelectedPanel);
            // listen for save event
            // validate ad save solar panel to db
            // disable drawing mode
            // show update modal
        }

        function deleteSolarPanel(panel, index) {
            solarPanelServices.deletePanel(vm.solar, panel)
                .then( function (response) {
                    vm.solar.panels.splice(index, 1);
                }, function (errorResponse) {
                    console.log('cannot delete panel!');
                });
        }

        function savePanelArea() {
            if (!drawingServices.overlayDataArray.length) {
                alertServices.showWarningDrawSolarPanelArea();
                return;
            }

            solarPanelServices.savePanel(vm.solar)
                .then( function(response) {
                    // push to vm.solar.panels the response panel
                    vm.solar.panels.push(response.panel);
                }, function(errorResponse) {
                   console.log('error creating panel');
                   console.log(errorResponse);
                });

            stopPanelDrawingMode();
        }

        function deleteSelectedPanel() {
            console.log('delete selected panel is called');
            solarPanelServices.clearSelectedPanel();
            $rootScope.showDeleteSelectedBtn = false;
        }

        function stopPanelDrawingMode() {
            drawingServices.stopDrawingMode();
            hideDrawingButtons();

            for(var key in panelListeners) {
                if (panelListeners.hasOwnProperty(key)) {
                    if(panelListeners[key]) {
                        panelListeners[key]();
                        panelListeners[key] = null;
                    }
                }
            }
        }

        function onPanelItemClick (panel) {
            solarPanelServices.onPanelClick(panel);
        }

        /* End of Solar Panel Tab Functions */

        /* Photos Tab Functions */

        function initializeScreenshot () {
            screenshotServices.startDrawing(solar, local);

            if (!screenshotTakenListener) {
                screenshotTakenListener = $rootScope.$on('screenshot-taken', uploadScreenshotPhoto);
            }
        }

        function uploadScreenshotPhoto (e, blob) {
            var file = uploadServices.parseScreenshotPhoto(blob);
            if(file) {
                uploadServices.uploadSolarPhoto(file, vm.solar)
                    .then(function(response){
                        var emit = $rootScope.$emit('solar-screenshot-photo-uploaded', response.solar_file);
                        emit = null;
                    }, function(err){
                        console.log(err);
                    });
            }
            if(screenshotTakenListener) {
                screenshotTakenListener();
                screenshotTakenListener = null;
            }
        }

        function editSolarPhotoCaption (newCaption, solarFile) {
            console.log('Edit Photo caption: ' + newCaption);
            var oldCaption = solarFile.caption;

            vm.solar.updatePhotoCaption(solarFile, newCaption)
                .then( function(response) {
                    console.log('success');
                    console.log(response);
                }, function(errorResponse) {
                    console.log('error!');
                    // Set old caption
                    console.log(errorResponse);
                });
        }

        function changePhotoFromScreenshot (photo, index) {
            screenshotServices.startDrawing(vm.solar, local);

            if (!changePhotoFromScreenshotListener) {
                changePhotoFromScreenshotListener = $rootScope.$on('screenshot-taken', function(e, blob){
                    console.log('change photo from screenshot listener called!');

                    var file = uploadServices.parseScreenshotPhoto(blob);
                    if (file) {
                        uploadServices.updateSolarPhoto(file, vm.solar, photo)
                            .then(function (response) {
                                console.log('successfully updated photo!');
                                console.log(response);

                                var emit = $rootScope.$emit('solar-screenshot-photo-updated', response.solar_file, index);
                                vm.solar.photos[index] = response.solar_file;
                                emit = null;

                            }, function (err) {
                                console.log(err);
                            });
                    }
                    if(changePhotoFromScreenshotListener) {
                        changePhotoFromScreenshotListener();
                        changePhotoFromScreenshotListener = null;
                    }
                });
            }
        }

        function uploadSolarPhoto (file, errorFiles) {
            if(file) {
                uploadServices.uploadSolarPhoto(file, vm.solar)
                    .then(function(response){
                        vm.solar.photos.push(response.solar_file);
                    }, function(errorResponse){
                        console.log('upload error');
                        console.log(errorResponse);
                    });
            } else {
                var errFile = errorFiles && errorFiles[0];
                alertServices.showInvalidFileUpload();
            }
        }

        function openPhotoMenu ($mdOpenMenu, ev) {
            $mdOpenMenu(ev);
        }

        function updateSolarPhoto (file, photo, index, errorFiles) {
            console.log('update photo index: '+index);

            if (file) {
                uploadServices.updateSolarPhoto(file, vm.solar, photo)
                    .then(function (response) {
                        console.log('successfully updated photo!');
                        console.log(response);
                        vm.solar.photos[index] = response.solar_file;
                    }, function (errorResponse) {
                        console.log('upload error');
                        console.log(errorResponse);
                    });
            } else {
                var errFile = errorFiles && errorFiles[0];
                alertServices.showInvalidFileUpload();
            }

        }

        function deletePhoto (photo, index) {
            vm.solar.deletePhoto(photo)
                .then( function (response) {
                    vm.solar.photos.splice(index, 1);

                }, function (errorResponse) {

                    console.log(errorResponse);
                    console.log('failed deleting photo');

                });

        }

        function previewImage (ev, photo) {
            modalServices.previewImage(ev, photo, vm.local)
                .then( function(response) {
                    console.log(response);
                }, function(errorResponse) {
                    var solar = $rootScope.local[0],
                        dialog = $rootScope.local[1].showSolarDetailInfowindow;
                    dialog(solar);

                    $rootScope.solarDetailSelectedTab = 2;
                });
        }

        /* End of Photos Tab Functions */


        /* Non-Scope Functions */

        function postToServer() {
            var deferred = $q.defer();

            var tempPanels = vm.solar.panels;
            vm.solar.panels = [];

            // PUT /api/solars/:id
            vm.solar.customPUT(vm.solar)
                .then(function (response) {
                    deferred.resolve(response);
                }, function (errorResponse) {
                    console.log('error Response');
                    deferred.reject(errorResponse);
                }).finally(function(){
                    vm.solar.panels = tempPanels;
                });

            return deferred.promise;
        }


        function cleanUp() {
            console.log('on destroy triggered');
            // Cancel Clean up if Screenshot mode is on
            if($rootScope.showScreenshotButtons) return;

            if(screenshotPhotoUploadedListener) {
                screenshotPhotoUploadedListener();
                screenshotPhotoUploadedListener = null;
            }

            hideAreaPolygon();
            hideCurrentMarker();
            hideSolarPanels();

            //Destroy listener
            destroyListeners();

            vm.stopDrawingMode();
            vm.areaPolygon = null;
            vm.currentMarker = null;

            console.log('done clean up');
        }

        function destroyListeners () {
            if (screenshotTakenListener) {
                screenshotTakenListener();
                screenshotTakenListener = null;
            }

            if(screenshotPhotoUploadedListener) {
                screenshotPhotoUploadedListener();
                screenshotPhotoUploadedListener = null;
            }

            if (changePhotoFromScreenshotListener) {
                changePhotoFromScreenshotListener();
                changePhotoFromScreenshotListener = null;
            }

            if (screenshotPhotoUpdateListener) {
                screenshotPhotoUpdateListener();
                screenshotPhotoUpdateListener = null;
            }
        }


        function clearCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.destroyMarker(vm.currentMarker);
            }
        }

        function hideCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.hideMarker(vm.currentMarker);
            }
        }

        function initializeSolar () {
            if (vm.solar == undefined || vm.solar == null) return;

            var solar = vm.solar;

            // Draw Polygon
            if(solar.area) {
                if(vm.areaPolygon) {
                    gmapServices.updatePolygon(vm.areaPolygon, solar.area);
                } else {
                    vm.areaPolygon = gmapServices.createPolygon(solar.area);
                }

                if( !vm.areaPolygon.getMap()) {
                    gmapServices.showPolygon(vm.areaPolygon);
                }
            }

            gmapServices.panTo(solar.coordinates);
            gmapServices.setZoomInDefault();
        }

        function initializeSolarPanels () {
            solarPanelServices.initializePanels(vm.solar.panels);
        }

        function hideAreaPolygon() {
            if (vm.areaPolygon) {
                gmapServices.hidePolygon(vm.areaPolygon);
            }
        }

        function hideSolarPanels() {
            solarPanelServices.hidePanels();
            vm.solar.panels = [];
        }

        /* Functions here */


        /* Drawing Functions */

        function saveArea() {
            if (!drawingServices.overlay) {
                alertServices.showWarningDrawSiteArea();
                return;
            }

            vm.solar.area = drawingServices.overlayDataArray;

            if (vm.areaPolygon) {
                if (!vm.areaPolygon.getMap()) {
                    vm.areaPolygon.setMap(gmapServices.map);
                }
                gmapServices.updatePolygon(vm.areaPolygon, vm.solar.area);
            } else {
                vm.areaPolygon = gmapServices.createPolygon(vm.solar.area);
            }

            vm.stopDrawingMode();
        }

        function cancelDrawing() {
            if (vm.areaPolygon && !vm.areaPolygon.getMap()) {
                gmapServices.showPolygon(vm.areaPolygon);
            } else {
                vm.areaPolygon = null;
            }

            vm.stopDrawingMode();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                $rootScope.showDeleteSelectedBtn = false;
                $rootScope.showSaveAreaBtn = false;
            }
        }

        function hideDrawingButtons() {
            $rootScope.showMapCancelBtn = false;
            $rootScope.showDeleteSelectedBtn = false;
            $rootScope.showSaveAreaBtn = false;
        }

        /* End of Drawing Functions */

        /* Drawing Solar Panel Functions */

        function currentLocationChanged() {
            // Reverse Geocode position
            if (vm.currentMarker) {
                gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);
                gmapServices.centerMarker(vm.currentMarker);

                vm.solar.coordinates = vm.currentMarker.getPosition().toJSON();

                gmapServices.reverseGeocode(vm.solar.coordinates)
                    .then(function (result) {
                        var formatted_address = result[0].formatted_address;
                        $log.info(formatted_address);
                        vm.solar.address = formatted_address;
                    });
            }
        }

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('solarListController', ['$rootScope', '$scope', 'Solars', '$filter', 'solarGmapServices', solarListController]);

    function solarListController($rootScope, $scope, Solars, $filter, solarGmapServices) {
        var vm = this;

        // complete list of Solars from the server
        $rootScope.solarList = [];

        // search filters for Solars
        vm.search = '';

        //vm.searchSolarFilters = {
        //    project_name: '',
        //    client_name: '',
        //    state: '',
        //    status: ''
        //};
        vm.searchSolarFilters = {
            '$': ''
        };

        /* MD Table Vars */

        vm.mdTableVars = {
            order: 'project_name',
            limit: 10,
            page: 1
        };

        // Table Header
        vm.tableHeaderList = [
            {
                'name': 'project_name',
                'label': 'Project'
            },
            {
                'name': 'client_name',
                'label': 'Client'
            },
            {
                'name': 'state',
                'label': 'State'
            },
            {
                'name': 'status',
                'label': 'Status'
            }
        ];


        vm.initialize = initialize;
        vm.filterSolars = filterSolars;
        vm.onClickRow = onClickRow;
        vm.viewSolarDetail = viewSolarDetail;
        vm.initialize();

        function initialize () {
            loadSolars();

            $scope.$watch(angular.bind(vm, function(){
                return vm.search;
            }), startFilter);
        }

        function onClickRow (solar) {
            // access solar var since it will be
            // transformed to restangular object

            console.log('Row Clicked! '+solar.project_name);

            if(solar && solar.id) {
                solarGmapServices.openSolarInfoWindowById(solar.id);
            }
            return false;
        }

        function viewSolarDetail (_solar) {
            $rootScope.$emit('show-solar-detail', {solar: _solar});
        }

        function loadSolars () {
            Solars.getList()
                .then(function (result) {
                    console.log('Success fetching solars');
                    //console.log(result);
                    // always cache the latest result to serve whenever we're offline
                    $rootScope.solarList = result;
                    vm.filterSolars();
                }, function (reason) {
                    console.log('Error when fetching solars');
                    // serve previously cached result when offline
                    //vm.solarList = storageServices.getSCIPs();
                });
        }

        function startFilter () {
            console.log('starting filter');
            console.log(vm.search);
            //for (var key in vm.searchSolarFilters) {
            //    console.log('key: '+key);
            //    if (vm.searchSolarFilters.hasOwnProperty(key)) {
            //        vm.searchSolarFilters[key] = vm.search;
            //    }
            //}
            //vm.searchSolarFilters.project_name = vm.search;
            vm.searchSolarFilters['$'] = vm.search;
            filterSolars();
        }

        //function emptyFilter () {
        //    for (var key in vm.searchSolarFilters) {
        //        if (vm.searchSolarFilters.hasOwnProperty(key)) {
        //            vm.searchSolarFilters[key] = '';
        //        }
        //    }
        //}

        function filterSolars () {
            // TODO: Add filter depend on role user authenticated
            // filter local list of solars
            // based on search criteria before
            // assigning to global list of solars
            if(isEmptyFilter()) {
                $rootScope.solars = $rootScope.solarList;
            } else {
                var filtered = $filter('filter')($rootScope.solarList, vm.searchSolarFilters, false);

                $rootScope.solars = filtered;
            }
        }

        function isEmptyFilter () {
            return vm.search === null || vm.search.trim() === '';
        }
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('screenshotImageConfirmController', ['$scope', '$timeout', 'modalServices', '$mdDialog', 'imagePreview', screenshotImageConfirmController]);

    function screenshotImageConfirmController ($scope, $timeout, modalServices, $mdDialog, imagePreview) {
        var vm = this;

        vm.imagePreview = {
            src: '',
            file: null
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch('imagePreview', updateImage);

            vm.imagePreview = imagePreview;
        }

        function updateImage () {
            if (vm.imagePreview && vm.imagePreview.file) {
                var a = new FileReader();
                a.onload = function (e) {
                    var dataURI = e.target.result;
                    $timeout(function () {
                        vm.imagePreview.src = dataURI;
                    });
                }
                a.readAsDataURL(vm.imagePreview.file);
            }
        }

        function save () {
            console.log('saving');
            modalServices.resolveHideModal();
        }

        function cancel () {
            console.log('cancel');
            modalServices.closeModal();
        }

        /* Non Scope Functions here */
    }
}());
(function () {
    'use strict';

    angular.module('solarApp')
        .controller('previewImageController', ['$scope', '$timeout', 'modalServices', 'photo', previewImageController]);

    function previewImageController($scope, $timeout, modalServices, photo) {
        var vm = this;
        vm.photo = null;

        vm.initialize = initialize;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            vm.photo = photo;
        }

        function close() {
            console.log('cancel');
            modalServices.resolveHideModal();
        }
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('mainController', ['$mdSidenav', mainController]);

    function mainController ($mdSidenav) {
        var vm = this;

        /* Side Nav Menus */
        vm.menu = [
            {
                link: '#',
                title: 'Admin',
                icon: 'group'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.initialize = initialize;
        vm.toggleSideNav = buildToggler('sidenav');

        vm.initialize();

        /* Controller Functions here */
        function initialize () {

        }

        /* Non Scope Functions here */
        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle()
                    .then(function () {
                        console.log("toggle " + navID + " is done");
                    });
            }
        }
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('indexController', ['$scope', '$rootScope', '$timeout', 'modalServices', 'gmapServices',
        function ($scope, $rootScope, $timeout, modalServices, gmapServices) {
            var vm = this;

            // Selected tab in Solar Detail Dialog
            $rootScope.solarDetailSelectedTab = 0;

            // last SOLAR clicked
            $rootScope.selectedSolar = null;

            // Cancel button on drawing
            $rootScope.showMapCancelBtn = false;

            // Delete Selected Area when drawing
            $rootScope.showDeleteSelectedBtn = false;

            // Show Solar List on Bottom
            $rootScope.showSolarList = false;

            // Save Area Button on Creating/Updating SOLAR
            $rootScope.showSaveAreaBtn = false;

            // Screenshot Buttons
            $rootScope.showScreenshotButtons = false;

            $rootScope.showStrokeWidth = false;

            $rootScope.screenshotShapeFillColor = '';
            $rootScope.screenshotShapeStrokeColor = '';

            // Show Treasure Overlay Spinner
            $rootScope.spinner = {
                active: false
            };

            // Save Button for Creating/Updating Solar Panels
            // within Update Solar Feature
            //$rootScope.showSavePanelBtn = false;


            vm.initialize = initialize;
            vm.showAddSolarModal = showAddSolarModal;
            vm.toggleSolarList = toggleSolarList;
            vm.saveArea = saveArea;
            vm.cancelDrawing = cancelDrawing
            vm.deleteSelected = deleteSelected;

            vm.showStrokeWidthOptions = showStrokeWidthOptions;
            vm.endScreenshotMode = endScreenshotMode;
            vm.addTextBubble = addTextBubble;
            vm.startScreenshot = startScreenshot;

            vm.screenshotShapeFillColor = '';
            vm.screenshotShapeStrokeColor = '';
            vm.screenshotShapeStrokeWidth = '';

            vm.initialize();

            function initialize() {
                console.log('initialize called');

                watchScreenshotModels();
            }

            function watchScreenshotModels () {
                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeStrokeColor;
                }), function (newVal) {
                    //console.log('screenshot shape stroke color is changed: ' + newVal);
                    $rootScope.screenshotShapeStrokeColor = newVal;
                });

                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeFillColor;
                }), function (newVal) {
                    //console.log('screenshot shape fill color is changed: ' + newVal);
                    $rootScope.screenshotShapeFillColor = newVal;
                });

                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeStrokeWidth;
                }), function (newVal) {
                    //console.log('screenshot shape stroke color is changed: ' + newVal);
                    $rootScope.screenshotShapeStrokeWidth = newVal;
                });
            }


            function showAddSolarModal(ev) {
                // This will trigger "modal-opened" event
                modalServices.showAddSolar(ev).then(
                  function (result) {
                      gmapServices.setZoomDefault();
                      var solar = result;
                      $timeout(function () {
                          $rootScope.solarList.push(solar);
                      //    $scope.filterScips();
                      });
                  }, function (reason) {
                      gmapServices.setZoomDefault();
                      //$timeout(function () {
                      //    $scope.filterScips();
                      //});
                  }
              );
            }

            function toggleSolarList () {
                $rootScope.showSolarList = !$rootScope.showSolarList;
            }

            /**
             * Drawing Functions
             */

            function saveArea () {
                $rootScope.$broadcast('save-area');
            }

            function cancelDrawing () {
                $rootScope.$broadcast('cancel-drawing');
            }

            function deleteSelected () {
                $rootScope.$broadcast('delete-selected');
            }

            /* Screenshot Functions */
            function startScreenshot () {
                $rootScope.$broadcast('start-screenshot');
            }

            function addTextBubble () {
                $rootScope.$broadcast('add-screenshot-text-bubble');
            }

            function showStrokeWidthOptions () {
                console.log('stroke width options clicked');
                $rootScope.showStrokeWidth = !$rootScope.showStrokeWidth;
            }

            function endScreenshotMode () {
                console.log('broadcasting screenshot-cancelled');
                $rootScope.$broadcast('screenshot-cancelled');
            }

    }]);
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('gmapController', ['$rootScope', '$timeout', 'solarGmapServices', 'modalServices', gmapController]);

    function gmapController($rootScope, $timeout, solarGmapServices, modalServices) {

        var vm = this;

        vm.initialize = initialize;
        vm.showSolarDetailInfowindow = showSolarDetailInfowindow;

        // Call initialize when loading controller
        vm.initialize();

        function initialize () {
            $rootScope.$watchCollection('solars', function () {
                console.log('solars changed!');

                // Dont show markers if Screenshot mode is on
                //if ($rootScope.showScreenshotButtons || $rootScope.updateSolarModalOpened) return;

                solarGmapServices.initializeSolarMarkers($rootScope.solars);
            });

            //$rootScope.$watch('selectedSolar', function () {
            //    vm.showSolarDetailInfowindow($rootScope.selectedSolar);
            //});

            /*
             *  Listen for modal-opened event then
             *  hide all markers and infowindow
             *  and hide list table
             */
            $rootScope.$on('modal-opened', hideMarkers);

            /*
            *  Listen for modal-dismissed event then
            *  show all markers
            */
            $rootScope.$on('modal-dismissed', showMarkers);

            $rootScope.$on('show-solar-detail', function (event, args) {
                vm.showSolarDetailInfowindow(args.solar);
            });

            /*
            *  Trigger a modal
            *  show Solar Detail
            */
            $(document).on('click', '.btn_view_solar_detail', function() {
               $rootScope.solarDetailSelectedTab = 0;
               vm.showSolarDetailInfowindow($rootScope.selectedSolar);
            });
        }

        function showSolarDetailInfowindow (_solar) {
            if(!(_solar && _solar.id)) return;

            solarGmapServices.hideSolarMarkers();

            var defered = modalServices.showUpdateSolar(_solar, vm, event);
            defered.then(function (response) {
                console.log('modalServices.showUpdateSolar response:');
                console.log(response);

                    if (!response) return;

                    solarGmapServices.gmapService.setZoomDefault();
                    solarGmapServices.showSolarMarkers();

                    if($rootScope.selectedSolar && response) {
                        $rootScope.selectedSolar.coordinates = response.coordinates;
                    }
                }, function (errorResponse) {

                    solarGmapServices.gmapService.setZoomDefault();
                    solarGmapServices.showSolarMarkers();


                    console.log('show update solar detail failed');
                    console.log(errorResponse);
                });
            //defered.finally(function(response){
            //    console.log('finally response: ');
            //    console.log(response);
            //    solarGmapServices.showSolarMarkers();
            //    solarGmapServices.gmapService.setZoomDefault();
            //});
        }


        function showMarkers () {
            solarGmapServices.showSolarMarkers();
            solarGmapServices.resetZoom();
        }


        function hideMarkers () {
            console.log('called from event : modal-opened');
            console.log('gmapcontroller hide markers');
            solarGmapServices.hideSolarMarkers();
            // Hide Solar List Table
            $rootScope.showSolarList = false;
        }

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('addSolarController', ['$log', '$rootScope', '$scope', 'usStates', 'modalServices', 'locationServices', 'gmapServices', 'drawingServices', 'Solars', 'alertServices', addSolarController]);

    function addSolarController($log, $rootScope, $scope, usStates, modalServices, locationServices, gmapServices, drawingServices, Solars, alertServices) {
        var vm = this;

        vm.states = usStates;

        vm.currentMarker = null;
        vm.areaPolygon = null;

        /*
        Represents the SOLAR Model
        TODO: Need to change it to Backbone Model or Breeze
        */
        vm.solar = {};

        var saveAreaListener = null;
        var cancelListener = null;
        var deleteSelectedListener = null;


        /* Scope Functions here */

        vm.initialize = initialize;
        vm.getCurrentLocation = getCurrentLocation;
        vm.pointCurrentLocation = pointCurrentLocation;
        vm.startDrawSite = startDrawSite;
        vm.stopDrawingMode = stopDrawingMode;
        vm.closeModal = closeModal;
        vm.saveSolar = saveSolar;

            vm.initialize();


        function initialize() {

            $scope.$watch(angular.bind(vm, function() {
                if(vm.currentMarker) {
                    return vm.currentMarker.getPosition();
                }
            }), currentLocationChanged);

            $rootScope.$on('overlay-complete', function() {
                $rootScope.$apply(function(){
                    $rootScope.showSaveAreaBtn = true;
                    $rootScope.showDeleteSelectedBtn = true;
                });
            });

            // Called everytime
            // when modal is closed/dismissed
            $scope.$on('$destroy', function(){
                cleanUp();
            });

        };


        function saveSolar () {
            if(vm.areaPolygon) {
                vm.solar.area = drawingServices.getAreaFormData(vm.areaPolygon);
            }

            Solars.post(vm.solar)
                .then( function(response){
                    console.log('Save Solar Response : ' + JSON.stringify(response));
                    modalServices.hideModalWithReponse(response.solar);
                }, function(response) {
                    console.log('error');
                    var error = response.data.errors;
                    var errorStr = JSON.stringify(error);
                    alertServices.showInvalidDataMessages(errorStr);
                });
        }


        function getCurrentLocation () {
          locationServices.getCurrentLocation()
              .then(function(position){
                  // Clear current marker to
                  // display only one current marker
                  clearCurrentMarker();

                  gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);

                  // a watch triggers geocoding on the currentMarker
                  vm.currentMarker = locationServices.showCurrentLocation(position);
              });
        }


        function pointCurrentLocation () {
            // Clear current marker to
            // display only one current marker
            clearCurrentMarker();

            vm.currentMarker = locationServices.showDraggableLocation();

            gmapServices.addListener(vm.currentMarker, 'dragend', function(val) {
                gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);
                $scope.$apply();
            });
        }


        function startDrawSite() {
            hideAreaPolygon();

            // Show Cancel Map button
            $rootScope.showMapCancelBtn = true;

            drawingServices.startDrawingMode();

            saveAreaListener = $rootScope.$on('save-area', saveArea);
            cancelListener = $rootScope.$on('cancel-drawing', cancelDrawing);
            deleteSelectedListener = $rootScope.$on('delete-selected', deleteSelected);
        }


        function stopDrawingMode() {
            drawingServices.stopDrawingMode();

            hideDrawingButtons();

            if (cancelListener) {
                cancelListener();
                cancelListener = null;
            }

            if(saveAreaListener) {
                saveAreaListener();
                saveAreaListener = null;
            }
        }


        function closeModal() {
            modalServices.closeModal();
        }

        /* Functions here */

        function hideDrawingButtons() {
            $rootScope.showMapCancelBtn = false;
            $rootScope.showDeleteSelectedBtn = false;
            $rootScope.showSaveAreaBtn = false;
        }

        function clearCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.destroyMarker(vm.currentMarker);
            }
        }

        function currentLocationChanged() {
            // Reverse Geocode position
            if (vm.currentMarker) {
                gmapServices.centerMarker(vm.currentMarker);

                vm.solar.coordinates = vm.currentMarker.getPosition().toJSON();

                gmapServices.reverseGeocode(vm.solar.coordinates)
                    .then(function (result) {
                        var formatted_address = result[0].formatted_address;
                        $log.info(formatted_address);
                        vm.solar.address = formatted_address;
                    });
            }
        }


        function saveArea() {
            if (!drawingServices.overlay) {
                alertServices.showWarningDrawSiteArea();
                return;
            }

            vm.solar.area = drawingServices.overlayDataArray;

            if (vm.areaPolygon) {
                if (!vm.areaPolygon.getMap()) {
                    vm.areaPolygon.setMap(gmapServices.map);
                }
                gmapServices.updatePolygon(vm.areaPolygon, vm.solar.area);
            } else {
                vm.areaPolygon = gmapServices.createPolygon(vm.solar.area);
            }

            vm.stopDrawingMode();
        }


        function cancelDrawing() {
            if (vm.areaPolygon && !vm.areaPolygon.getMap()) {
                gmapServices.showPolygon(vm.areaPolygon);
            } else {
                vm.areaPolygon = null;
            }

            vm.stopDrawingMode();
        }


        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                $rootScope.showDeleteSelectedBtn = false;
                $rootScope.showSaveAreaBtn = false;
            }
        }


        function cleanUp() {
            hideAreaPolygon();
            hideCurrentMarker();
            vm.stopDrawingMode();
            vm.areaPolygon = null;
            vm.currentMarker = null;
        }


        function hideCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.hideMarker(vm.currentMarker);
            }
        }


        function hideAreaPolygon() {
            if (vm.areaPolygon) {
                gmapServices.hidePolygon(vm.areaPolygon);
            }
        }

    }
}());
(function(){
    'use strict';

    var usStates = [
        "Alabama",
        "Alaska",
        "American Samoa",
        "Arizona",
        "Arkansas",
        "California",
        "Colorado",
        "Connecticut",
        "Delaware",
        "District Of Columbia",
        "Federated States Of Micronesia",
        "Florida",
        "Georgia",
        "Guam",
        "Hawaii",
        "Idaho",
        "Illinois",
        "Indiana",
        "Iowa",
        "Kansas",
        "Kentucky",
        "Louisiana",
        "Maine",
        "Marshall Islands",
        "Maryland",
        "Massachusetts",
        "Michigan",
        "Minnesota",
        "Mississippi",
        "Missouri",
        "Montana",
        "Nebraska",
        "Nevada",
        "New Hampshire",
        "New Jersey",
        "New Mexico",
        "New York",
        "North Carolina",
        "North Dakota",
        "Northern Mariana Islands",
        "Ohio",
        "Oklahoma",
        "Oregon",
        "Palau",
        "Pennsylvania",
        "Puerto Rico",
        "Rhode Island",
        "South Carolina",
        "South Dakota",
        "Tennessee",
        "Texas",
        "Utah",
        "Vermont",
        "Virgin Islands",
        "Virginia",
        "Washington",
        "West Virginia",
        "Wisconsin",
        "Wyoming"
    ];

    var solarStatuses = [
        'In-Process',
        'Submitted',
        'Approved'
    ];

    angular.module('solarApp')
        .value('usStates', usStates)
        .value('solarStatuses', solarStatuses);

}());


