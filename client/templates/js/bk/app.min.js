(function(){
    'use strict';

    angular
        .module('solarApp', ['ngMaterial', 'ngAnimate', 'restangular', 'oitozero.ngSweetAlert', 'ngFileUpload', 'treasure-overlay-spinner', 'angularInlineEdit', 'colorpicker.module'])

        .config(['RestangularProvider', function(RestangularProvider) {
            //set the base url for api calls on our RESTful services
            var baseUrl = window.location.origin + '/api';
            RestangularProvider.setBaseUrl(baseUrl);
        }]);

    //.run(function (editableOptions, editableThemes) {
    //    editableThemes['angular-material'] = {
    //        formTpl: '<form class="editable-wrap"></form>',
    //        noformTpl: '<span class="editable-wrap"></span>',
    //        controlsTpl: '<md-input-container class="editable-controls" ng-class="{\'md-input-invalid\': $error}"></md-input-container>',
    //        inputTpl: '',
    //        errorTpl: '<div ng-messages="{message: $error}"><div class="editable-error" ng-message="message">{{$error}}</div></div>',
    //        buttonsTpl: '<span class="editable-buttons"></span>',
    //        submitTpl: '<md-button type="submit" class="md-primary"><md-icon style="color:white;">save</md-icon></md-button>',
    //        cancelTpl: '<md-button type="button" class="md-warn" ng-click="$form.$cancel()">cancel</md-button>'
    //    };
    //
    //    editableOptions.theme = 'angular-material';
    //});

    //.config(function ($mdThemingProvider) {
    //    $mdThemingProvider.theme('default')
    //        .primaryPalette('red')
    //        .accentPalette('pink');
    //});

    console.log('solar app initialized!');

}());


(function(){
'use strict';

angular.module('solarApp')
    .factory('webServices', ['webRequestServices', webServices]);
    
    function webServices(webRequestServices) {
        var service = {};

        service.getSolars = getSolars;
        service.getSolarDetail = getSolarDetail;
        service.updateSolar = updateSolar;

        function getSolars () {
            return webRequestServices.get('/api/solars');
        }

        function getSolarDetail (solarId) {
            console.log('getsolardetail solarID : ' + solarId);

            return webRequestServices.get('/api/solars/' + solarId);
        }

        function updateSolar (solarId, data) {
            return webRequestServices.put('/api/solars/' + solarId, data);
        }
        
        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('webRequestServices', ['$http', 'Upload', webRequestServices]);
    
    function webRequestServices($http, Upload) {
        var service = {};

        // fix 401 errors being automatically handled by browsers
        var baseUrl = location.protocol + "//" + "user:pass@" + location.host + "/";

        function buildParams(params) {
            if (params != null && params.isObject)
                return _.map(params, function (key, val) {
                    return key + "=" + value;
                }).join("&");
            return "";
        };


        service.get = function (url, params) {
            return $http.get(baseUrl + url + "?" + buildParams(params));
        };


        service.post = function (url, params) {
            return $http({
                url: baseUrl + url,
                method: "POST",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.put = function (url, params) {
            return $http({
                url: baseUrl + url,
                method: "PUT",
                data: JSON.stringify(params),
                headers: {'Content-Type': 'application/json'}
            });
        };


        service.delete = function (url) {
            return $http.delete(url);
        };


        service.upload = function (url, fields, file) {
            return Upload.upload({
                url: baseUrl + url,
                method: 'POST',
                fields: fields,
                file: file
            });
        };


        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('utilServices', [utilServices]);

    function utilServices () {
        var service = {};

        var hexChar = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

        service.byteToHex = byteToHex;

        /**
         * 0-255 to 00-ff
         * @param b
         */
        function byteToHex(b) {
            return hexChar[(b >> 4) & 0x0f] + hexChar[b & 0x0f];
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('Solars', ['Restangular', 'Upload', Solars]);
    
    function Solars (Restangular, Upload) {
        var solarModel = Restangular.all('solars');

        Restangular.extendModel('solars', function (model) {
            model.upload = function (_file, _caption) {
                var uploadUrl = model.getRestangularUrl() + '/' + 'photos',
                    caption = _caption || '';

                console.log('custom solar method : UPLOAD');

                return Upload.upload({
                           url: uploadUrl,
                           method: 'POST',
                           data: {file: _file, caption: _caption}
                       });
            };
            return model;
        });

        return solarModel;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('solarGmapServices', ['$rootScope', 'gmapServices', solarGmapServices]);

    function solarGmapServices($rootScope, gmapServices) {
        var service = {};

        service.solarMarkers = [];

        service.gmapService = gmapServices;

        service.initialize = initialize;
        service.initializeSolarMarkers = initializeSolarMarkers;
        service.showSolarMarkers = showSolarMarkers;
        service.hideSolarMarkers = hideSolarMarkers;
        service.resetZoom = resetZoom;

        service.initialize();


        function initialize () {
            gmapServices.createMap('map-canvas');
        }


        function initializeSolarMarkers (solars) {
            if (solars == null) return;

            solars.forEach(function (solar, key) {
                var marker = gmapServices.createCustomMarker(solar.coordinates);

                if ('undefined' === typeof service.solarMarkers[key])
                    service.solarMarkers[key] = [];

                var template = createInfowindowTemplate(solar);
                marker.infowindow = gmapServices.createInfoBox(template);

                marker.solar = solar;
                service.solarMarkers.push(marker);

                google.maps.event.addListener(marker, 'click', onClickSolarMarker);
            });
        }
        /* End of showSolarMarkers */


        function onClickSolarMarker () {
            gmapServices.openInfoBox(this.infowindow, this);
            //gmapServices.closeInfoBox();
            gmapServices.panTo(this.getPosition());

            // Refresh variable
            $rootScope.selectedSolar = null;
            $rootScope.$apply();

            // this refers to clicked marker
            $rootScope.selectedSolar = this.solar;
            $rootScope.$apply();
        }


        function showSolarMarkers () {
            if (!service.solarMarkers || service.solarMarkers.length <= 0) return;

            gmapServices.showMarkers(service.solarMarkers);
        }


        function hideSolarMarkers () {
            if(!service.solarMarkers || service.solarMarkers.length <= 0) return;

            gmapServices.hideMarkers(service.solarMarkers);

            // Close any infowindow
            gmapServices.closeInfoBox();
        }


        function resetZoom () {
            gmapServices.setZoomDefault();
        }


        function createInfowindowTemplate(solar) {
            return '<div class="marker_info none" id="marker_info">' +
                   '<div class="info" id="info">' +
                   '<h4>' + solar.project_name + '<span></span></h4>' +
                   '<span>' + solar.state + '</span>' +
                   '<a href="#!" class="infowindow_btn btn_view_solar_detail">More info</a>' +
                   '<span class="arrow"></span>' +
                   '</div>' +
                   '</div>';
        }


        return service;

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('screenshotServices', ['$rootScope', '$timeout', 'gmapServices', 'modalServices', 'utilServices', 'infoWindowServices', 'loaderServices', screenshotServices]);

    function screenshotServices ($rootScope, $timeout, gmapServices, modalServices, utilServices, infoWindowServices, loaderServices) {
        var service = {};

        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.screenShotDrawingManager = null;
        service.screenshotDrawingListener = null;

        service.shapes = [];
        service.selectedShape = null;
        service.lineWidth = 1.0;

        var circleOptions = null;
        var polygonOptions = null;
        var polylineOptions = null;
        var rectangleOptions = null;

        $rootScope.hasScreenshotSelectedShape = false;

        var mapInitialTransform = '';

        /**
         * Functions
         */
        service.startDrawing = startDrawing;
        service.endDrawing = endDrawing;
        service.onClickShape = onClickShape;
        service.selectShape = selectShape;
        service.selectLastShape = selectLastShape;
        service.deleteShapeAtIndex = deleteShapeAtIndex;
        service.deleteSelected = deleteSelected;


        service.solar = null;


        var screenshotCancelledListener = null;
        var mapClickListener = null;

        function startDrawing (solar) {
            service.solar = solar;

            initDrawingManager();

            initScreenshotListeners();

            // Always Hide Modal if any
            modalServices.hideModal();

            showScreenshotTools();
            watchShapeAtrributesValue();
            console.log('initialized screenshot');
        }

        function watchShapeAtrributesValue () {
            $rootScope.$watch('screenshotShapeStrokeColor', onChangeStrokeColor);

            $rootScope.$watch('screenshotShapeFillColor', onChangeFillColor);

            $rootScope.$watch('screenshotShapeStrokeWidth', onChangeStrokeWidth);

            $rootScope.$on('delete-selected', deleteSelected);

            $rootScope.$on('add-screenshot-text-bubble', addTextBubble);

            $rootScope.$on('start-screenshot', startScreenshot);
        }

        function startScreenshot() {
            console.log('startScreenshot is called');

            if (!service.screenshotDrawingManager) {
                service.screenshotDrawingManager = gmapServices.createDrawingManager();
                gmapServices.showDrawingManager(service.screenshotDrawingManager);
            }

            if (!service.screenshotDrawingListener) {
                service.screenshotDrawingListener = gmapServices.addListener(
                    service.screenshotDrawingManager, 'overlaycomplete', onFinishScreenshot);
            }

            var setDragTool = {drawingMode: null};
            service.screenshotDrawingManager.setOptions(setDragTool);

            var drawOptions = {
                drawingMode: google.maps.drawing.OverlayType.RECTANGLE,
                drawingControl: false,
                rectangleOptions: {
                    fillOpacity: 0,
                    strokeOpacity: 0.9,
                    strokeColor: '#ffffff',
                    zIndex: 3
                }
            };
            service.screenshotDrawingManager.setOptions(drawOptions);
            hideScreenshotTools();
        }

        function stopScreenshot() {
            if (service.screenshotDrawingManager) {
                gmapServices.hideDrawingManager(service.screenshotDrawingManager);
                service.screenshotDrawingManager = null;
            }

            if (service.screenshotDrawingListener) {
                gmapServices.removeListener(service.screenshotDrawingListener);
                service.screenshotDrawingListener = null;
            }
        };

        function onFinishScreenshot (eArgs) {
            loaderServices.showLoader();
            stopScreenshot();

            var rectangle = eArgs.overlay;
            gmapServices.hidePolygon(rectangle);

            var bounds = rectangle.getBounds();
            var upperRight = gmapServices.fromLatLngToContainerPixel(bounds.getNorthEast());
            var lowerLeft = gmapServices.fromLatLngToContainerPixel(bounds.getSouthWest());
            var box = {
                x: lowerLeft.x,
                y: upperRight.y,
                width: upperRight.x - lowerLeft.x,
                height: lowerLeft.y - upperRight.y
            };

            convertMapTransformToLeftRight();

            $timeout(function () {
                html2canvas(document.getElementById('map-canvas'), {
                    "logging": true,
                    "imageTimeout": 120000,
                    "proxy": "/html2canvasproxy"
                }).then(function (canvas) {
                    console.log('html2canvas callback!')

                    loaderServices.hideLoader(true);

                    revertMapTransform();
                    initDrawingManager();

                    var tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = box.width;
                    tmpCanvas.height = box.height;

                    var context = tmpCanvas.getContext('2d');
                    context.drawImage(canvas, box.x, box.y, box.width, box.height, 0, 0, box.width, box.height);

                    var toBlobFunction = function (blob) {
                        var file = blob;
                        var options = {
                            file: file,
                            caption: 'Screenshot'
                        };

                        modalServices.showScreenshotImageConfirmation(options)
                            .then(function (result) {
                                $rootScope.$broadcast('screenshot_taken', file);
                                //service.endDrawing();
                            });
                    };

                    tmpCanvas.toBlob(toBlobFunction);
                });
            });
        }

        /**
         * Fix for screenshot when Google Map is scrolled or panned.
         * Thanks for answer from: http://stackoverflow.com/questions/24046778/html2canvas-does-not-work-with-google-maps-pan
         */
        function convertMapTransformToLeftRight() {
            mapInitialTransform = $(".gm-style>div:first>div").css("transform");
            var comp = mapInitialTransform.split(",") //split up the transform matrix
            var mapleft = parseFloat(comp[4]) //get left value
            var maptop = parseFloat(comp[5])  //get top value
            $(".gm-style>div:first>div").css({ //get the map container. not sure if stable
                "transform": "none",
                "left": mapleft,
                "top": maptop
            });
        };

        function revertMapTransform() {
            $(".gm-style>div:first>div").css({
                "transform": mapInitialTransform,
                left: 0,
                top: 0
            });
        }

        function addTextBubble () {
            if (!mapClickListener) {
                mapClickListener = gmapServices.addMapListener('click', function(e){
                    infoWindowServices.addInfoWindow(e.latLng);
                    cancelAddTextBubble();
                });
                gmapServices.setMapCursorCrosshair();
            }

            if (service.screenshotDrawingManager) {
                var setDragTool = {drawingMode: null};
                service.screenshotDrawingManager.setOptions(setDragTool);
            }
        }

        function cancelAddTextBubble() {
            if (mapClickListener) {
                gmapServices.setMapCursorDefault();
                gmapServices.removeListener(mapClickListener);
                mapClickListener = null;
            }
        }

        function onChangeFillColor() {
            var color = $rootScope.screenshotShapeFillColor;
            if(!color) return;

            var rgba = /rgba\(([0-9\.]+),([0-9\.]+),([0-9\.]+),([0-9\.]+)\)/.exec(color);
            var colorHexString = '#'
                + utilServices.byteToHex(parseFloat(rgba[1]))
                + utilServices.byteToHex(parseFloat(rgba[2]))
                + utilServices.byteToHex(parseFloat(rgba[3]));

            circleOptions = setDrawingOption('circleOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polygonOptions = setDrawingOption('polygonOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polylineOptions = setDrawingOption('polylineOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['fillColor', 'fillOpacity'], [colorHexString, parseFloat(rgba[4])]);

            updateSelectedShape();
        }

        function onChangeStrokeColor () {
            var color = $rootScope.screenshotShapeStrokeColor;
            if (!color) return;

            var rgba = /rgba\(([0-9\.]+),([0-9\.]+),([0-9\.]+),([0-9\.]+)\)/.exec(color);
            var colorHexString = '#'
                + utilServices.byteToHex(parseFloat(rgba[1]))
                + utilServices.byteToHex(parseFloat(rgba[2]))
                + utilServices.byteToHex(parseFloat(rgba[3]));

            circleOptions = setDrawingOption('circleOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polygonOptions = setDrawingOption('polygonOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            polylineOptions = setDrawingOption('polylineOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['strokeColor', 'strokeOpacity'], [colorHexString, parseFloat(rgba[4])]);

            updateSelectedShape();
        }

        function onChangeStrokeWidth () {
            var lineWidth = $rootScope.screenshotShapeStrokeWidth;

            $timeout(function () {
                service.lineWidth = lineWidth;
            });

            circleOptions = setDrawingOption('circleOptions', ['strokeWeight'], [lineWidth]);
            polygonOptions = setDrawingOption('polygonOptions', ['strokeWeight'], [lineWidth]);
            polylineOptions = setDrawingOption('polylineOptions', ['strokeWeight'], [lineWidth]);
            rectangleOptions = setDrawingOption('rectangleOptions', ['strokeWeight'], [lineWidth]);

            updateSelectedShape();
        }

        function initScreenshotListeners() {
            screenshotCancelledListener = $rootScope.$on('screenshot-cancelled', service.endDrawing);
        }

        function showScreenshotTools () {
            // Show Map Cancel button
            $rootScope.showScreenshotButtons = true;
        }

        function initDrawingManager() {
            if (service.drawingManager) {
                // Reinitialize Drawing Listener
                initDrawingListener();
                console.log('Reinitialize Drawing Listener on Screenshot Services');
                return;
            }

            service.drawingManager = gmapServices.createDrawingToolsManager();
            gmapServices.showDrawingManager(service.drawingManager);

            initDrawingListener();

            console.log('init drawing manager on Screenshot Services');
        }

        function initDrawingListener() {
            if (gmapServices.apiAvailable()) {
                if ( !service.drawingCompleteListener) {
                    service.drawingCompleteListener = gmapServices.addListener(
                        service.drawingManager, 'overlaycomplete', overlayCompleteListener);
                }

                console.log('init drawing listener');

                $timeout(function () {
                    showScreenshotTools();
                });
            }
        }

        function overlayCompleteListener(eventArgs) {
            var object = {
                shape: eventArgs.overlay,
                type: eventArgs.type,
                listener: gmapServices.addListener(
                    eventArgs.overlay, 'click', service.onClickShape
                )
            }
            service.shapes.push(object);
            service.selectLastShape();
        }

        function onClickShape() {
            var index = _.findIndex(service.shapes, {shape: this})
            if (index >= 0) service.selectShape(service.shapes[index]);
        }

        function selectShape(shape) {
            if (service.selectedShape) {
                service.selectedShape.shape.setDraggable(false);
                if (service.selectedShape.type != google.maps.drawing.OverlayType.MARKER)
                    service.selectedShape.shape.setEditable(false);
            }

            var _shape = shape;
            $timeout(function () {
                service.selectedShape = _shape;
                if (service.selectedShape && service.selectedShape.shape) {
                    service.selectedShape.shape.setDraggable(true);
                    if (service.selectedShape.type != google.maps.drawing.OverlayType.MARKER)
                        service.selectedShape.shape.setEditable(true);

                    $rootScope.hasScreenshotSelectedShape = true;
                }
                ;
            });
        }

        function selectLastShape () {
            if (service.shapes.length > 0) {
                service.selectShape(service.shapes[service.shapes.length - 1]);
            } else {
                service.selectShape(null);
            }
        }

        function deleteSelected () {
            if (service.selectedShape) {
                deleteShapeAtIndex(_.indexOf(service.shapes, service.selectedShape));

                if(service.shapes.length <= 0) {
                    $rootScope.hasScreenshotSelectedShape = false;
                }
            }
        }

        function deleteShapeAtIndex(index) {
            if (index >= 0) {
                var object = service.shapes[index];
                service.shapes.splice(index, 1);
                gmapServices.removeListener(object.listener);
                gmapServices.hidePolygon(object.shape);
                delete object.shape;
                delete object.listener;
                service.selectedShape = null;
                service.selectLastShape();
            }
        }

        function endDrawing () {
            while (service.shapes.length > 0)
                service.deleteShapeAtIndex(service.shapes.length - 1);

            infoWindowServices.clearInfoWindows();
            hideScreenshotTools();
            destroyDrawingManager();
            modalServices.showModal();

            //$rootScope.$emit('show-solar-detail', {solar: service.solar});

            console.log('endDrawing is called');
        }

        function hideScreenshotTools () {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
                service.drawingManager = null;
            }

            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            $rootScope.showScreenshotButtons = false;
            $rootScope.showStrokeWidth = false;
        }

        function setDrawingOption(optionName, propertyNames, values) {
            if (service.drawingManager) {
                var options = service.drawingManager.get(optionName);
                if (options) {
                    for (var i = 0; i < propertyNames.length && i < values.length; i++) {
                        var propertyName = propertyNames[i];
                        var value = values[i];
                        if (options.hasOwnProperty(propertyName)) {
                            options[propertyName] = value;
                        }
                    }
                    service.drawingManager.set(optionName, options);
                    return options;
                }
            }
            return null;
        };

        function updateSelectedShape() {
            if (!service.selectedShape) return;

            if (service.selectedShape.type == google.maps.drawing.OverlayType.MARKER) {

            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.POLYLINE) {
                service.selectedShape.shape.setOptions(polylineOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.CIRCLE) {
                service.selectedShape.shape.setOptions(circleOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.POLYGON) {
                service.selectedShape.shape.setOptions(polygonOptions);
            } else if (service.selectedShape.type == google.maps.drawing.OverlayType.RECTANGLE) {
                service.selectedShape.shape.setOptions(rectangleOptions);
            }
        }

        function destroyDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
                service.drawingManager = null;
            }

            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            screenshotCancelledListener();
            screenshotCancelledListener = null;
        };

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('modalServices', ['$rootScope', '$q', '$mdDialog', '$mdMedia', 'Solars', modalServices]);

    function modalServices($rootScope, $q, $mdDialog, $mdMedia, Solars) {

            var service = {};

            service.customFullscreen = $mdMedia('xs') || $mdMedia('sm');

            service.solarAddModal = null;
            service.showUpdateModal = null;
            service.showUploadSolarFileModal = null;
            service.showScreenshotImageConfirmationModal = null;

            /* Service Functions */
            service.showAddSolar = showAddSolar;
            service.showUpdateSolar = showUpdateSolar;
            service.showUploadSolarFile = showUploadSolarFile;
            service.hideModalWithReponse = hideModalWithReponse;
            service.showScreenshotImageConfirmation = showScreenshotImageConfirmation;
            service.closeModal = closeModal;
            service.hideModal = hideModal;
            service.showModal = showModal;


            function showAddSolar(ev) {
                var deferred = $q.defer();

                if (service.solarAddModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    service.solarAddModal = $mdDialog.show({
                        controller: 'addSolarController',
                        controllerAs: 'addSolarCtl',
                        templateUrl: '/solar/add',
                        parent: angular.element(document.querySelector('#solar-container')),
                        targetEvent: ev,
                        hasBackdrop: false,
                        fullscreen: service.customFullscreen,
                        onComplete: function (scope, element, options) {
                            //$('.md-dialog-container').addClass('flex-50');
                            //$('.md-dialog-container').addClass('display-left-md-dialog-container');
                            $('.md-scroll-mask').css('z-index', '0');
                        },
                        disableParentScroll: true,
                        autoWrap: true
                    });

                    service.solarAddModal.then(function (result) {
                        service.solarAddModal = null;
                        deferred.resolve(result);

                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");

                        service.solarAddModal = null;
                        deferred.reject(reason);
                    });
                }

                return deferred.promise;
            }


            function showUpdateSolar(solarId, event) {
                var deferred = $q.defer();

                if (service.showUpdateModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    var openModal = function(solarData) {
                        service.showUpdateModal = $mdDialog.show({
                            controller: 'updateSolarController',
                            controllerAs: 'updateSolarCtl',
                            templateUrl: '/solar/edit',
                            parent: angular.element(document.querySelector('#solar-container')),
                            targetEvent: event,
                            hasBackdrop: false,
                            fullscreen: service.customFullscreen,
                            disableParentScroll: true,
                            autoWrap: true,
                            resolve: {
                                solar: function () {
                                    return angular.copy(solarData);
                                }
                            },
                            onComplete: function (scope, element, options) {
                                $('.md-scroll-mask').css('z-index', '0');
                            }
                        });
                        service.showUpdateModal.then(function (result) {
                            service.showUpdateModal = null;
                            deferred.resolve(result);
                        }, function (reason) {
                            $rootScope.$broadcast("modal-dismissed");
                            service.showUpdateModal = null;
                            deferred.reject(reason);
                        });
                    };

                    // load Solar details before opening modal
                    var onGetSolarSucceed = function (result) {
                        console.log('on get solar succeed result: ');
                        console.log(result);
                        openModal(result);
                    };
                    var onGetSolarFail = function (result) {
                        if (result.status == 0 || result.status == 502) {
                            deferred.reject(result);
                        }
                    };
                    Solars.get(solarId).then(onGetSolarSucceed, onGetSolarFail);
                }
                return deferred.promise;
            }


            function showUploadSolarFile (solarFile, solarModel) {
                var deferred = $q.defer();

                if (service.showUploadSolarFileModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    $rootScope.$broadcast("modal-opened");

                    service.showUploadSolarFileModal = $mdDialog.show({
                        controller: 'uploadSolarFileController',
                        controllerAs: 'uploadSolarFileCtl',
                        templateUrl: '/solar/upload',
                        parent: angular.element(document.body),
                        hasBackdrop: false,
                        fullscreen: service.customFullscreen,
                        disableParentScroll: true,
                        autoWrap: true,
                        resolve: {
                            solar: function () {
                                return angular.copy(solarModel);
                            },
                            file: function () {
                                return angular.copy(solarFile)
                            }
                        },
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.showUploadSolarFileModal.then(function (result) {
                        service.showUploadSolarFileModal = null;
                        deferred.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        service.showUploadSolarFileModal = null;
                        deferred.reject(reason);
                    });
                }
                return deferred.promise;
            }

            function showScreenshotImageConfirmation (model) {
                console.log('showScreenshotImageConfirmation called');
                var deferred = $q.defer();
                if (service.showScreenshotImageConfirmationModal) {
                    // prevent multiple modals from being opened
                    deferred.reject("Modal already opened");
                } else {
                    service.showScreenshotImageConfirmationModal = $mdDialog.show({
                        controller: 'screenshotImageConfirmController',
                        controllerAs: 'screenshotImageConfirmCtl',
                        templateUrl: '/image/screenshot/confirm',
                        parent: angular.element(document.body),
                        hasBackdrop: false,
                        fullscreen: service.customFullscreen,
                        disableParentScroll: true,
                        autoWrap: true,
                        resolve: {
                            imagePreview: function () {
                                return model;
                            }
                        },
                        onComplete: function (scope, element, options) {
                            $('.md-scroll-mask').css('z-index', '0');
                        }
                    });

                    service.showScreenshotImageConfirmationModal.then( function(result) {
                        console.log('show screenshot modal save');
                        service.showScreenshotImageConfirmationModal = null;
                        deferred.resolve(result);
                    }, function (reason) {
                        console.log('show screenshot modal canceled');
                        service.showScreenshotImageConfirmationModal = null;
                        deferred.reject(reason);
                    });
                }

                return deferred.promise;
            }

            function hideModalWithReponse(data) {
                $mdDialog.hide(data);
            }

            // Temporarily Hide Infowindow
            function hideModal() {
                $('.md-dialog-container').css('display', 'none');
            }

            function showModal() {
                $('.md-dialog-container').css('display', 'flex');
            }

            // Close Modal
            function closeModal() {
              $mdDialog.cancel();
            }

            return service;
     }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('locationServices', ['$q', 'gmapServices', locationServices]);

    function locationServices($q, gmapServices) {
        var service = {};

        service.getCurrentLocation = function () {
            if(!navigator.geolocation) {
                console.log('Browser doesnt support Geolocation');
                return false;
            }
            var defer = $q.defer();

            navigator.geolocation.getCurrentPosition(function(position) {
               defer.resolve(position);
            });

            return defer.promise;
        };

        // Parameter must be a latLng
        service.showCurrentLocation = function (position) {
            var latLng = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            var marker = gmapServices.showCurrentLocation(latLng);
            var offset = 0.002;


            gmapServices.panToOffsetLeft(latLng, offset);
            gmapServices.setZoomInDefault();

            return marker;
        };

        service.showDraggableLocation = function () {
            var draggable = true,
                latLng = gmapServices.map.getCenter();

            var marker = gmapServices.showCurrentLocation(latLng, draggable);

            //gmapServices.panToOffsetLeft(latLng);

            return marker;
        };

        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('infoWindowServices', ['gmapServices', infoWindowServices]);

    function infoWindowServices (gmapServices) {
        var service = {};

        var uniqueId = 0;
        var openList = [];
        var closeList = [];

        service.addInfoWindow = addInfoWindow;
        service.clearInfoWindows = clearInfoWindows;

        function addInfoWindow(position) {
            var infoWindow = gmapServices.createCanvasInfoWindow();
            infoWindow.uniqueId = uniqueId++;
            infoWindow.setPosition(position);
            infoWindow.open();
            openList.push(infoWindow);
        }

        function clearInfoWindows() {
            while (openList.length > 0) {
                var infoWindow = openList[openList.length - 1];
                openList.splice(openList.length - 1, 1);
                gmapServices.hideCanvasInfoWindow(infoWindow);
                closeList.push(infoWindow);
            }
        }

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('solarApp')
        .factory('gmapServices', ['$log', '$q', gmapServices]);

    function gmapServices($log, $q) {
        var service = {};

        var MapTypeId = {
            USGSTopo: "USGS Topo"
        };

        service.MARKER_ICONS = {
            // IN-PROCESS
            RED: '/resources/images/red-dot.png',
            // SUBMITTED
            YELLOW: '/resources/images/yellow-dot.png',
            // APPROVED
            GREEN: '/resources/images/green-dot.png',
            // INVALID
            ERROR: '/resources/images/caution.png'
        };

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 6;
        service.ZOOM_IN_LEVEL = 17;

        service.map = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_OUT_LEVEL;

        service.defaultLatLng = new google.maps.LatLng(32.7577, -88.4376);

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.panToPolygon = panToPolygon;
        service.createPolyline = createPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.WMSGetTopoUrl = WMSGetTopoUrl;
        service.createWMSTopoMapType = createWMSTopoMapType;


        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId) {
            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.defaultLatLng,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                mapTypeControlOptions: {
                    position: google.maps.ControlPosition.LEFT_TOP,
                    mapTypeIds: [google.maps.MapTypeId.HYBRID, google.maps.MapTypeId.SATELLITE, MapTypeId.USGSTopo]
                },
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false
            };

            $(myMapId).height($(window).height() - (42));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // initialize geocoder
            service.geocoder = new google.maps.Geocoder();

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (42));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            var overlayView = new google.maps.OverlayView();
            overlayView.draw = function () {
            };
            overlayView.setMap(service.map);
            service.overlayView = overlayView;

            // Initialize USGS TOPO Map Layer
            service.createWMSTopoMapType();

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-solar-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyMarker(marker) {
            service.hideMarker(marker);
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
                //service.map.setZoom(service.defaultZoom);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.defaultLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, _color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: strokeColor,
                fillOpacity: 0,
                strokeColor: strokeColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polygon(polygonOptions);
        }

        function createPolygon(path, _color) {
            var polygon = service.initPolygon(path, _color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function panToPolygon(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach( function(path){
                bounds.extend(path);
            });

            service.panTo(bounds.getCenter());
        }

        function createPolyline(path) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 5,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        /**
         * Start of TOPOGRAPHY Map Code
         */

        /*The code that reads in the WMS file.  To change the WMS layer the user would update the layers line.  As this is constructed now you need to have this code for each WMS layer.
         Check with your Web Map Server to see what are the required components of the address.  You may need to add a couple of segements.  For example, the ArcServer WMS requires
         a CRS value which is tacked on to the end of the url.  For an example visit http://www.gisdoctor.com/v3/arcserver_wms.html
         */

         function WMSGetTopoUrl(tile, zoom) {
            var projection = service.map.getProjection();
            var zpow = Math.pow(2, zoom);
            var ul = new google.maps.Point(tile.x * 256.0 / zpow, (tile.y + 1) * 256.0 / zpow);
            var lr = new google.maps.Point((tile.x + 1) * 256.0 / zpow, (tile.y) * 256.0 / zpow);
            var ulw = projection.fromPointToLatLng(ul);
            var lrw = projection.fromPointToLatLng(lr);
            //The user will enter the address to the public WMS layer here.  The data must be in WGS84
            var baseURL = "http://basemap.nationalmap.gov/arcgis/services/USGSTopo/MapServer/WMSServer?&REQUEST=GetMap&SERVICE=WMS&VERSION=1.3&LAYERS="; //begining of the WMS URL ending with a "?" or a "&".
            var format = "image%2Fjpeg"; //type of image returned  or image/jpeg
            //The layer ID.  Can be found when using the layers properties tool in ArcMap
            var layers = "0";
            var srs = "EPSG:4326"; //projection to display. This is the projection of google map. Don't change unless you know what you are doing.
            var bbox = ulw.lat() + "," + ulw.lng() + "," + lrw.lat() + "," + lrw.lng();
            //Add the components of the URL together
            var url = baseURL + layers + "&Styles=default" + "&SRS=" + srs + "&BBOX=" + bbox + "&width=256" + "&height=256" + "&format=" + format + "&BGCOLOR=0xFFFFFF&TRANSPARENT=true" + "&reaspect=false" + "&CRS=EPSG:4326";
            return url;
        }

        function createWMSTopoMapType() {
            if (!service.apiAvailable()) return null;
            // Creating the WMS layer options.  This code creates the Google imagemaptype options for each wms layer.
            // In the options the function that calls the individual wms layer is set.
            var wmsOptions = {
                alt: MapTypeId.USGSTopo,
                getTileUrl: service.WMSGetTopoUrl,
                isPng: false,
                maxZoom: 16,
                minZoom: 1,
                name: MapTypeId.USGSTopo,
                tileSize: new google.maps.Size(256, 256),
                credit: 'USGS'
            };

            // init the USGS Topo map type
            var wmsMapType = new google.maps.ImageMapType(wmsOptions);
            service.map.mapTypes.set(MapTypeId.USGSTopo, wmsMapType);
        }

        return service;
    }
}());


(function(){
'use strict';
//TODO error handler to display in angular material way coming from flask response
angular.module('solarApp')
    .factory('errorServices', [errorServices]);
    
    function errorServices() {
        var service = {};
        
        return service;
    }

}());
(function(){
'use strict';

angular.module('solarApp')
    .factory('drawingServices', ['gmapServices', 'modalServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, modalServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.cancelDrawingMode = cancelDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;


        function initDrawingManager() {
            if (service.drawingManager) {
                // Reinitialize Drawing Listener
                service.initDrawingListener();
                console.log('Reinitialize Drawing Listener');
                return;
            }

            console.log('init drawing manager');

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);

            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
            console.log('added drawing complete listener');
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if(service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();

                console.log('shape changed');
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            service.overlayStrokeColor = strokeColor || '';

            // Show Map Cancel button
            $rootScope.showMapCancelBtn = true;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);

            // Always Hide Modal if any
            modalServices.hideModal();

            console.log('start drawing mode');
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            //show this modal again once drawing mode is off
            modalServices.showModal();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if( !service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if(!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            //switch (service.overlayType) {
            //    case google.maps.drawing.OverlayType.POLYGON:
            return getPolygonCoords(_area);
            //        break;
            //    case google.maps.drawing.OverlayType.RECTANGLE:
            //        data = service.getRectangleCoords();
            //}
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        return service;
    }

}());

(function () {
'use strict';

angular.module('solarApp')
    .factory('alertServices', ['SweetAlert', '$mdToast', alertServices]);

    function alertServices(SweetAlert, $mdToast) {
        var service = {};

        service.showWarningDrawSiteArea = showWarningDrawSiteArea;
        service.showInvalidDataMessages = showInvalidDataMessages;
        service.showWarningDrawSolarPanelArea = showWarningDrawSolarPanelArea;
        service.showInvalidFileUpload = showInvalidFileUpload;
        service.showFileUploadSuccess = showFileUploadSuccess;

        function showWarningDrawSiteArea () {
            SweetAlert.swal({
                title: 'Please draw site area.',
                type: 'warning'
            });
        }

        function showWarningDrawSolarPanelArea() {
            SweetAlert.swal({
                title: 'Please Solar Panel area.',
                type: 'warning'
            });
        }

        function showInvalidFileUpload () {
            SweetAlert.swal({
                title: 'Invalid File Uploaded.',
                type: 'error'
            });
        }

        function showFileUploadSuccess () {
            $mdToast.show(
                $mdToast.simple()
                    .textContent('File Successfully Uploaded.')
                    .position('top right')
                    .hideDelay(3000)
            );
        }

        function showInvalidDataMessages (errorStr) {
            SweetAlert.swal({
                title: 'Invalid Data',
                text: errorStr,
                type: 'error',
                confirmButtonText: 'Close'
            });
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('uploadSolarFileController', ['$rootScope', 'modalServices', 'solar', 'file', uploadSolarFileController]);

    function uploadSolarFileController ($rootScope, modalServices, solar, file) {
        var vm = this;

        vm.initialize = initialize;
        vm.closeModal = closeModal;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            console.log('upload solar file controller initialized!');

            console.log('solar: ');
            console.log(solar);

            console.log('file: ');
            console.log(file);
        }

        function closeModal() {
            modalServices.closeModal();
            //$rootScope.$broadcast('show-solar-detail');
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('updateSolarController', ['$log', '$timeout', '$rootScope', '$scope', '$q', 'solar', 'usStates', 'modalServices', 'locationServices', 'gmapServices', 'drawingServices', 'alertServices', 'screenshotServices', 'loaderServices', updateSolarController]);

    function updateSolarController($log, $timeout, $rootScope, $scope, $q, solar, usStates, modalServices, locationServices, gmapServices, drawingServices, alertServices, screenshotServices, loaderServices) {
        var vm = this;

        vm.states = usStates;

        /*
         Represents the SOLAR Model
         TODO: Need to change it to Backbone Model or Breeze
         */

        vm.solar = {
            id: 0,
            panels: []
        };

        vm.solarPanelPolygons = [];

        // Panel Stroke Color
        var panelStrokeColor = '#ff0000';

        vm.currentMarker = null;
        vm.areaPolygon = null;

        /* Drawing Listeners Container */
        var saveAreaListener = null;
        var cancelListener = null;
        var deleteSelectedListener = null;


        /* Drawing Listeners for Panel */
        var savePanelAreaListener = null;
        var cancelPanelListener = null;
        var deleteSelectedPanelListener = null;

        /* Scope Functions here */
        vm.initialize = initialize;
        vm.updateSolar = updateSolar;
        vm.closeModal = closeModal;

        vm.initialize();

        /* General Info Tab Functions */
        vm.getCurrentLocation = getCurrentLocation;
        vm.pointCurrentLocation = pointCurrentLocation;
        vm.startDrawSite = startDrawSite;
        vm.stopDrawingMode = stopDrawingMode;

        /* Solar Panels Tab Functions */
        vm.addSolarPanel = addSolarPanel;
        vm.onPanelItemClick = onPanelItemClick;

        /* Photos Tab Model */
        vm.uploadSolarPhotoModel = null;
        vm.uploadSolarPhotoErrorModel = null;

        /* Photos Tab Functions */
        vm.uploadSolarPhoto = uploadSolarPhoto;
        vm.openPhotoMenu = openPhotoMenu;
        vm.editSolarPhotoCaption = editSolarPhotoCaption;
        vm.initializeScreenshot = initializeScreenshot;

        /* Functions here */

        /* Scope Functions */
        function initialize () {
            $scope.$watch(angular.bind(vm, function() {
                return vm.solar;
            }), function (){
                initializeSolar();
                initializeSolarPanels();
            });

            vm.solar = solar;

            $scope.$watch(angular.bind(vm, function () {
                if (vm.currentMarker) {
                    return vm.currentMarker.getPosition();
                }
            }), currentLocationChanged);

            $rootScope.$on('overlay-complete', function () {
                $rootScope.$apply(function () {
                    $rootScope.showSaveAreaBtn = true;
                    $rootScope.showDeleteSelectedBtn = true;
                });
            });


            $scope.$on('$destroy', function () {
                console.log('on destroy');
                cleanUp();
            });

            console.log('update solar controller initialized');
            console.log(vm.solar);
        }


        function updateSolar () {
            console.log('updating solar');

            if (vm.areaPolygon) {
                vm.solar.area = drawingServices.getAreaFormData(vm.areaPolygon);
            }

            postToServer()
                .then( function(response) {

                    console.log('Update Solar Response : ' + JSON.stringify(response));
                    modalServices.hideModalWithReponse(response.solar);

                }, function(errorResponse) {

                    console.log(errorResponse);
                    var errorStr = JSON.stringify(errorResponse.data.errors);
                    alertServices.showInvalidDataMessages(errorStr);

                });
        }

        function closeModal() {
            modalServices.closeModal();
        }

        /* General Info Tab Functions */

        function getCurrentLocation () {
            locationServices.getCurrentLocation()
                .then(function (position) {
                    // Clear current marker to
                    // display only one current marker
                    clearCurrentMarker();

                    // a watch triggers geocoding on the currentMarker
                    vm.currentMarker = locationServices.showCurrentLocation(position);
                });
        }

        function pointCurrentLocation() {
            // Clear current marker to
            // display only one current marker
            clearCurrentMarker();

            vm.currentMarker = locationServices.showDraggableLocation();

            gmapServices.addListener(vm.currentMarker, 'dragend', function (val) {
                $scope.$apply();
            });
        }

        function startDrawSite() {
            hideAreaPolygon();

            drawingServices.startDrawingMode();

            saveAreaListener = $scope.$on('save-area', saveArea);
            cancelListener = $scope.$on('cancel-drawing', cancelDrawing);
            deleteSelectedListener = $scope.$on('delete-selected', deleteSelected);
        }


        function stopDrawingMode() {
            drawingServices.stopDrawingMode();

            hideDrawingButtons();

            if (cancelListener) {
                cancelListener();
                cancelListener = null;
            }

            if (deleteSelectedListener) {
                deleteSelectedListener();
                deleteSelectedListener = null;
            }

            if (saveAreaListener) {
                saveAreaListener();
                saveAreaListener = null;
            }
        }

        /* End General Info Tab Functions */


        /* Solar Panel Tab Functions */

        function addSolarPanel () {
            console.log('adding solar panel');
            // dismiss update modal
            // maintain of displaying the areaPolygon
            // enable drawing mode
            // show drawing controls
            startDrawPanel();

            // listen for save event
            // validate ad save solar panel to db
            // disable drawing mode
            // show update modal
        }

        function startDrawPanel() {
            drawingServices.startDrawingMode(panelStrokeColor);

            savePanelAreaListener = $scope.$on('save-area', savePanelArea);

            cancelPanelListener = $scope.$on('cancel-drawing', cancelPanelDrawing);
            deleteSelectedPanelListener = $scope.$on('delete-selected', deleteSelectedPanel);

            console.log('start draw panel is called');
        }

        function savePanelArea() {
            if (!drawingServices.overlayDataArray.length) {
                alertServices.showWarningDrawSolarPanelArea();
                return;
            }

            var polygon = gmapServices.initPolygon(drawingServices.overlayDataArray, panelStrokeColor);
            var ctr = vm.solar.panels.length + 1;

            var panel = {
                'name': 'Solar Panel ' + ctr,
                'area': drawingServices.getAreaFormData(polygon)
            };

            vm.solar.all('panels').post(panel)
                .then( function(response) {
                    // push to vm.solar.panels the response panel
                    vm.solar.panels.push(response.panel);

                    var newPanel = response.panel;
                    newPanel.polygon = polygon;
                    gmapServices.showPolygon(polygon);

                    vm.solarPanelPolygons.push(newPanel);

                    console.log('successs');
                    console.log(response);

                }, function(errorResponse) {

                   polygon = null;
                   console.log('error creating panel');
                   console.log(errorResponse);

                });

            stopPanelDrawingMode();
        }

        function cancelPanelDrawing() {
            //if (vm.panelPolygon && !vm.panelPolygon.getMap()) {
            //    gmapServices.showPolygon(vm.panelPolygon);
            //} else {
            //    vm.panelPolygon = null;
            //}

            // Show Solar Panel Polygon
            // on vm.solar.panels

            stopPanelDrawingMode();
            console.log('cancel panel drawing');
        }

        function deleteSelectedPanel() {
            console.log('delete selected panel is called');
        }

        function stopPanelDrawingMode() {
            drawingServices.stopDrawingMode();

            hideDrawingButtons();

            if (cancelListener) {
                cancelPanelListener();
                cancelPanelListener = null;
            }

            if (deleteSelectedPanelListener) {
                deleteSelectedPanelListener();
                deleteSelectedPanelListener = null;
            }

            if (savePanelAreaListener) {
                savePanelAreaListener();
                savePanelAreaListener = null;
            }
        }

        function getSolarPanelFormData (_solars) {
            var solarData = [];

            _solars.forEach(function(solar) {
               var tempSolar = {
                   'name': solar.name,
                   'area': solar.area
               };
               solarData.push(tempSolar);
            });

            return solarData;
        }

        var lastSelectedSolarPanel = null;

        function onPanelItemClick (panel) {
            console.log('panel clicked');

            if (lastSelectedSolarPanel) {
                gmapServices.resetPolygonFill(lastSelectedSolarPanel);
            }

            if(panel.polygon) {
                lastSelectedSolarPanel = panel.polygon;
                gmapServices.fillPolygon(lastSelectedSolarPanel);
                gmapServices.panToPolygon(panel.polygon);
            }

            // Remove Fill Polygon after 3 seconds
            $timeout(function(){
                gmapServices.resetPolygonFill(lastSelectedSolarPanel);
            }, 3000);
        }

        /* End of Solar Panel Tab Functions */

        /* Photos Tab Functions */

        function initializeScreenshot () {
            screenshotServices.startDrawing(solar);

            console.log('initialize screenshot');
        }

        function editSolarPhotoCaption (solar) {
            console.log('edit solar photo caption');
            console.log(solar);
        }

        function uploadSolarPhoto (file, errorFiles) {
            var f = file;
            var errFile = errorFiles && errorFiles[0];

            if(f) {
                loaderServices.showLoader();
                // if file is valid
                // trigger a modal to show progress and
                console.log('file is supported and no error');
                var defered = vm.solar.upload(file);

                defered.then( function(response) {
                        console.log(response.data);

                        var photo = response.data.solar_file;
                        vm.solar.photos.push(photo);

                        alertServices.showFileUploadSuccess();

                    }, function(errResponse) {

                        console.log('upload error');
                        console.log(errResponse);
                        alertServices.showInvalidFileUpload();

                    });

                defered.finally(function(){
                    loaderServices.hideLoader();
                });

            } else {
                console.log('file has error');
                console.log(errFile);
                alertServices.showInvalidFileUpload();
            }
        }


        function openPhotoMenu ($mdOpenMenu, ev) {
            $mdOpenMenu(ev);
        }

        /* End of Photos Tab Functions */


        /* Non-Scope Functions */

        function postToServer() {
            var deferred = $q.defer();

            // PUT /api/solars/:id
            vm.solar.customPUT(vm.solar)
                .then(function (response) {
                    deferred.resolve(response);
                }, function (errorResponse) {
                    console.log('error Response');
                    deferred.reject(errorResponse);
                });

            return deferred.promise;
        }


        function cleanUp() {
            hideAreaPolygon();
            hideCurrentMarker();
            hideSolarPanels();
            //vm.stopDrawingMode();
            vm.areaPolygon = null;
            vm.currentMarker = null;

            console.log('done clean up');
        }


        function clearCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.destroyMarker(vm.currentMarker);
            }
        }

        function hideCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.hideMarker(vm.currentMarker);
            }
        }

        function initializeSolar () {
            if (vm.solar == undefined || vm.solar == null) return;

            var solar = vm.solar;

            // Draw Polygon
            if(solar.area) {
                if(vm.areaPolygon) {
                    gmapServices.updatePolygon(vm.areaPolygon, solar.area);
                } else {
                    vm.areaPolygon = gmapServices.createPolygon(solar.area);
                }

                if( !vm.areaPolygon.getMap()) {
                    gmapServices.showPolygon(vm.areaPolygon);
                }
            }

            gmapServices.panTo(solar.coordinates);
            gmapServices.setZoomInDefault();
        }

        function initializeSolarPanels () {
            console.log('initializing solar panels');

            if(vm.solar.panels.length) {
                vm.solarPanelPolygons = angular.copy(vm.solar.panels);
                // Show Solar Panels
                // by creating polygons on map
                vm.solarPanelPolygons.forEach( function(panel, index) {
                    vm.solarPanelPolygons[index].polygon = gmapServices.createPolygon(panel.area, panelStrokeColor);
                });
            }
        }

        function hideAreaPolygon() {
            if (vm.areaPolygon) {
                gmapServices.hidePolygon(vm.areaPolygon);
            }
        }

        function hideSolarPanels() {
            vm.solarPanelPolygons.forEach(function (panel) {
                if (panel['polygon']) {
                    gmapServices.hidePolygon(panel['polygon']);
                    panel['polygon'] = null;
                }
            });

            vm.solar.panels = [];
            vm.solarPanelPolygons = [];
        }

        /* Functions here */


        /* Drawing Functions */

        function saveArea() {
            console.log('save area');

            if (!drawingServices.overlay) {
                alertServices.showWarningDrawSiteArea();
                return;
            }

            vm.solar.area = drawingServices.overlayDataArray;
            console.log('drawingServices.overlayDataArray');
            console.log(drawingServices.overlayDataArray);

            if (vm.areaPolygon) {
                if (!vm.areaPolygon.getMap()) {
                    vm.areaPolygon.setMap(gmapServices.map);
                }
                gmapServices.updatePolygon(vm.areaPolygon, vm.solar.area);
            } else {
                vm.areaPolygon = gmapServices.createPolygon(vm.solar.area);
            }

            vm.stopDrawingMode();
        }

        function cancelDrawing() {
            if (vm.areaPolygon && !vm.areaPolygon.getMap()) {
                gmapServices.showPolygon(vm.areaPolygon);
            } else {
                vm.areaPolygon = null;
            }

            vm.stopDrawingMode();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                $rootScope.showDeleteSelectedBtn = false;
                $rootScope.showSaveAreaBtn = false;
            }
        }

        function hideDrawingButtons() {
            $rootScope.showMapCancelBtn = false;
            $rootScope.showDeleteSelectedBtn = false;
            $rootScope.showSaveAreaBtn = false;
        }

        /* End of Drawing Functions */

        /* Drawing Solar Panel Functions */

        function currentLocationChanged() {
            // Reverse Geocode position
            if (vm.currentMarker) {
                gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);
                gmapServices.centerMarker(vm.currentMarker);

                vm.solar.coordinates = vm.currentMarker.getPosition().toJSON();

                gmapServices.reverseGeocode(vm.solar.coordinates)
                    .then(function (result) {
                        var formatted_address = result[0].formatted_address;
                        $log.info(formatted_address);
                        vm.solar.address = formatted_address;
                    });
            }
        }

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('solarListController', ['$rootScope', 'Solars', '$filter', solarListController]);

    function solarListController($rootScope, Solars, $filter) {
        var vm = this;

        // complete list of Solars from the server
        $rootScope.solarList = []

        // search filters for Solars
        vm.search = {
            status: '',
            project_name: '',
            client_name: '',
            state: '',
            county: ''
        };


        vm.initialize = initialize;
        vm.filterSolars = filterSolars;

        vm.initialize();

        function initialize () {
            loadSolars();

            $rootScope.$watch('solarList', function () {

            });
        }


        function loadSolars () {
            //webServices.getSolars()
            Solars.getList()
                .then(function (result) {
                    console.log('Success fetching solars');
                    //console.log(result);
                    // always cache the latest result to serve whenever we're offline
                    $rootScope.solarList = result;
                    vm.filterSolars();
                }, function (reason) {
                    console.log('Error when fetching solars');
                    // serve previously cached result when offline
                    //vm.solarList = storageServices.getSCIPs();
                });
        }


        function filterSolars () {
            // TODO: Add filter depend on role user authenticated
            // filter local list of solars
            // based on search criteria before
            // assigning to global list of solars
            if(isEmptyFilter()) {
                $rootScope.solars = $rootScope.solarList;
            } else {
                $rootScope.solars = $filter("filter")($rootScope.solarList, vm.search, false);
            }
        }


        function isEmptyFilter () {
            return vm.search === null || (
                    vm.search.status.trim() === '' &&
                    vm.search.project_name.trim() === '' &&
                    vm.search.client_name.trim() === '' &&
                    vm.search.state.trim() === '' &&
                    vm.search.county.trim() === ''
                );
        }


    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('screenshotImageConfirmController', ['$scope', '$timeout', 'modalServices', '$mdDialog', 'imagePreview', screenshotImageConfirmController]);

    function screenshotImageConfirmController ($scope, $timeout, modalServices, $mdDialog, imagePreview) {
        var vm = this;

        vm.imagePreview = {
            src: '',
            file: null
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch('imagePreview', updateImage);

            vm.imagePreview = imagePreview;
        }

        function updateImage () {
            if (vm.imagePreview && vm.imagePreview.file) {
                var a = new FileReader();
                a.onload = function (e) {
                    var dataURI = e.target.result;
                    $timeout(function () {
                        vm.imagePreview.src = dataURI;
                    });
                }
                a.readAsDataURL(vm.imagePreview.file);
            }
        }

        function save () {
            console.log('saving');
        }

        function cancel () {
            console.log('cancel');
            modalServices.closeModal();
        }

        /* Non Scope Functions here */
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('mainController', ['$mdSidenav', mainController]);

    function mainController ($mdSidenav) {
        var vm = this;

        /* Side Nav Menus */
        vm.menu = [
            {
                link: '',
                title: 'Home',
                icon: 'dashboard'
            },
            {
                link: '',
                title: 'Admin',
                icon: 'group'
            }
        ];
        vm.admin = [
            {
                link: 'showListBottomSheet($event)',
                title: 'Settings',
                icon: 'settings'
            },
            {
                link: '',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.initialize = initialize;
        vm.toggleSideNav = buildToggler('sidenav');

        vm.initialize();

        /* Controller Functions here */
        function initialize () {

        }

        /* Non Scope Functions here */
        function buildToggler(navID) {
            return function () {
                $mdSidenav(navID)
                    .toggle()
                    .then(function () {
                        console.log("toggle " + navID + " is done");
                    });
            }
        }
    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('indexController', ['$scope', '$rootScope', '$timeout', 'modalServices', 'gmapServices',
        function ($scope, $rootScope, $timeout, modalServices, gmapServices) {
            var vm = this;

            // last SOLAR clicked
            $rootScope.selectedSolar = null;

            // Cancel button on drawing
            $rootScope.showMapCancelBtn = false;

            // Delete Selected Area when drawing
            $rootScope.showDeleteSelectedBtn = false;

            // Show Solar List on Bottom
            $rootScope.showSolarList = false;

            // Save Area Button on Creating/Updating SOLAR
            $rootScope.showSaveAreaBtn = false;

            // Screenshot Buttons
            $rootScope.showScreenshotButtons = false;

            $rootScope.showStrokeWidth = false;

            $rootScope.screenshotShapeFillColor = '';
            $rootScope.screenshotShapeStrokeColor = '';

            // Show Treasure Overlay Spinner
            $rootScope.spinner = {
                active: false
            };

            // Save Button for Creating/Updating Solar Panels
            // within Update Solar Feature
            //$rootScope.showSavePanelBtn = false;


            vm.initialize = initialize;
            vm.showAddSolarModal = showAddSolarModal;
            vm.toggleSolarList = toggleSolarList;
            vm.saveArea = saveArea;
            vm.cancelDrawing = cancelDrawing
            vm.deleteSelected = deleteSelected;

            vm.showStrokeWidthOptions = showStrokeWidthOptions;
            vm.endScreenshotMode = endScreenshotMode;
            vm.addTextBubble = addTextBubble;
            vm.startScreenshot = startScreenshot;

            vm.screenshotShapeFillColor = '';
            vm.screenshotShapeStrokeColor = '';
            vm.screenshotShapeStrokeWidth = '';

            vm.initialize();

            function initialize() {
                console.log('initialize called');

                watchScreenshotModels();
            }

            function watchScreenshotModels () {
                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeStrokeColor;
                }), function (newVal) {
                    //console.log('screenshot shape stroke color is changed: ' + newVal);
                    $rootScope.screenshotShapeStrokeColor = newVal;
                });

                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeFillColor;
                }), function (newVal) {
                    //console.log('screenshot shape fill color is changed: ' + newVal);
                    $rootScope.screenshotShapeFillColor = newVal;
                });

                $scope.$watch(angular.bind(vm, function () {
                    return vm.screenshotShapeStrokeWidth;
                }), function (newVal) {
                    //console.log('screenshot shape stroke color is changed: ' + newVal);
                    $rootScope.screenshotShapeStrokeWidth = newVal;
                });
            }


            function showAddSolarModal(ev) {
                // This will trigger "modal-opened" event
                modalServices.showAddSolar(ev).then(
                  function (result) {
                      gmapServices.setZoomDefault();
                      var solar = result;
                      $timeout(function () {
                          $rootScope.solarList.push(solar);
                      //    $scope.filterScips();
                      });
                  }, function (reason) {
                      gmapServices.setZoomDefault();
                      //$timeout(function () {
                      //    $scope.filterScips();
                      //});
                  }
              );
            }

            function toggleSolarList () {
                $rootScope.showSolarList = !$rootScope.showSolarList;
            }

            /**
             * Drawing Functions
             */

            function saveArea () {
                $rootScope.$broadcast('save-area');
            }

            function cancelDrawing () {
                $rootScope.$broadcast('cancel-drawing');
            }

            function deleteSelected () {
                $rootScope.$broadcast('delete-selected');
            }

            /* Screenshot Functions */
            function startScreenshot () {
                $rootScope.$broadcast('start-screenshot');
            }

            function addTextBubble () {
                $rootScope.$broadcast('add-screenshot-text-bubble');
            }

            function showStrokeWidthOptions () {
                console.log('stroke width options clicked');
                $rootScope.showStrokeWidth = !$rootScope.showStrokeWidth;
            }

            function endScreenshotMode () {
                console.log('broadcasting screenshot-cancelled');
                $rootScope.$broadcast('screenshot-cancelled');
            }

    }]);
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('gmapController', ['$rootScope', '$timeout', 'solarGmapServices', 'modalServices', gmapController]);

    function gmapController($rootScope, $timeout, solarGmapServices, modalServices) {

        var vm = this;

        vm.initialize = initialize;
        vm.showSolarDetailInfowindow = showSolarDetailInfowindow;

        // Call initialize when loading controller
        vm.initialize();

        function initialize () {
            $rootScope.$watchCollection('solars', function () {
                solarGmapServices.initializeSolarMarkers($rootScope.solars);
            });

            //$rootScope.$watch('selectedSolar', function () {
            //    vm.showSolarDetailInfowindow($rootScope.selectedSolar);
            //});

            //$rootScope.$on('show-solar-detail', function () {
            //    console.log('show solar detail event is called');
            //    vm.showSolarDetailInfowindow($rootScope.selectedSolar);
            //});

            /*
             *  Listen for modal-opened event then
             *  hide all markers and infowindow
             *  and hide list table
             */
            $rootScope.$on('modal-opened', hideMarkers);

            /*
            *  Listen for modal-dismissed event then
            *  show all markers
            */
            $rootScope.$on('modal-dismissed', showMarkers);

            //$rootScope.$on('show-solar-detail', function (event, args) {
            //    console.log('show solar detail event called');
            //    vm.showSolarDetailInfowindow(args.solar);
            //});

            /*
            *  Trigger a modal
            *  show Solar Detail
            */
            $(document).on('click', '.btn_view_solar_detail', function() {
               console.log('infowindow btn clicked!');
               vm.showSolarDetailInfowindow($rootScope.selectedSolar);
            });
        }


        function showSolarDetailInfowindow (_solar) {
            if(!(_solar && _solar.id)) return;

            $rootScope.tempSolars = $rootScope.solars;
            $rootScope.solars = [];

            modalServices.showUpdateSolar(_solar.id, event)
                .then(function (response) {
                    console.log('show update solar detail success');
                    console.log(response);

                    solarGmapServices.gmapService.setZoomDefault();


                    if($rootScope.selectedSolar && response) {
                        console.log('$rootScope.selectedSolar');
                        console.log($rootScope.selectedSolar);
                        $rootScope.selectedSolar.coordinates = response.coordinates;
                    }

                    $timeout(function () {
                        $rootScope.solars = $rootScope.tempSolars;
                    });

                }, function (errorResponse) {
                    solarGmapServices.gmapService.setZoomDefault();
                    $timeout(function () {
                        $rootScope.solars = $rootScope.tempSolars;
                    });
                    console.log('show update solar detail failed');
                    console.log(errorResponse);
                });
        }


        function showMarkers () {
            solarGmapServices.showSolarMarkers();
            solarGmapServices.resetZoom();
        }


        function hideMarkers () {
            console.log('called from event : modal-opened');
            console.log('gmapcontroller hide markers');
            solarGmapServices.hideSolarMarkers();
            // Hide Solar List Table
            $rootScope.showSolarList = false;
        }

    }
}());
(function(){
'use strict';

angular.module('solarApp')
    .controller('addSolarController', ['$log', '$rootScope', '$scope', 'usStates', 'modalServices', 'locationServices', 'gmapServices', 'drawingServices', 'Solars', 'alertServices', addSolarController]);

    function addSolarController($log, $rootScope, $scope, usStates, modalServices, locationServices, gmapServices, drawingServices, Solars, alertServices) {
        var vm = this;

        vm.states = usStates;

        vm.currentMarker = null;
        vm.areaPolygon = null;

        /*
        Represents the SOLAR Model
        TODO: Need to change it to Backbone Model or Breeze
        */
        vm.solar = {};

        var saveAreaListener = null;
        var cancelListener = null;
        var deleteSelectedListener = null;


        /* Scope Functions here */

        vm.initialize = initialize;
        vm.getCurrentLocation = getCurrentLocation;
        vm.pointCurrentLocation = pointCurrentLocation;
        vm.startDrawSite = startDrawSite;
        vm.stopDrawingMode = stopDrawingMode;
        vm.closeModal = closeModal;
        vm.saveSolar = saveSolar;

            vm.initialize();


        function initialize() {

            $scope.$watch(angular.bind(vm, function() {
                if(vm.currentMarker) {
                    return vm.currentMarker.getPosition();
                }
            }), currentLocationChanged);

            $rootScope.$on('overlay-complete', function() {
                $rootScope.$apply(function(){
                    $rootScope.showSaveAreaBtn = true;
                    $rootScope.showDeleteSelectedBtn = true;
                });
            });

            // Called everytime
            // when modal is closed/dismissed
            $scope.$on('$destroy', function(){
                cleanUp();
            });

        };


        function saveSolar () {
            if(vm.areaPolygon) {
                vm.solar.area = drawingServices.getAreaFormData(vm.areaPolygon);
            }

            Solars.post(vm.solar)
                .then( function(response){
                    console.log('Save Solar Response : ' + JSON.stringify(response));
                    modalServices.hideModalWithReponse(response.solar);
                }, function(response) {
                    console.log('error');
                    var error = response.data.errors;
                    var errorStr = JSON.stringify(error);
                    alertServices.showInvalidDataMessages(errorStr);
                });
        }


        function getCurrentLocation () {
          locationServices.getCurrentLocation()
              .then(function(position){
                  // Clear current marker to
                  // display only one current marker
                  clearCurrentMarker();

                  gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);

                  // a watch triggers geocoding on the currentMarker
                  vm.currentMarker = locationServices.showCurrentLocation(position);
              });
        }


        function pointCurrentLocation () {
            // Clear current marker to
            // display only one current marker
            clearCurrentMarker();

            vm.currentMarker = locationServices.showDraggableLocation();

            gmapServices.addListener(vm.currentMarker, 'dragend', function(val) {
                gmapServices.setZoomIfGreater(gmapServices.ZOOM_IN_LEVEL);
                $scope.$apply();
            });
        }


        function startDrawSite() {
            hideAreaPolygon();

            // Show Cancel Map button
            $rootScope.showMapCancelBtn = true;

            drawingServices.startDrawingMode();

            saveAreaListener = $rootScope.$on('save-area', saveArea);
            cancelListener = $rootScope.$on('cancel-drawing', cancelDrawing);
            deleteSelectedListener = $rootScope.$on('delete-selected', deleteSelected);
        }


        function stopDrawingMode() {
            drawingServices.stopDrawingMode();

            hideDrawingButtons();

            if (cancelListener) {
                cancelListener();
                cancelListener = null;
            }

            if(saveAreaListener) {
                saveAreaListener();
                saveAreaListener = null;
            }
        }


        function closeModal() {
            modalServices.closeModal();
        }

        /* Functions here */

        function hideDrawingButtons() {
            $rootScope.showMapCancelBtn = false;
            $rootScope.showDeleteSelectedBtn = false;
            $rootScope.showSaveAreaBtn = false;
        }

        function clearCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.destroyMarker(vm.currentMarker);
            }
        }

        function currentLocationChanged() {
            // Reverse Geocode position
            if (vm.currentMarker) {
                gmapServices.centerMarker(vm.currentMarker);

                vm.solar.coordinates = vm.currentMarker.getPosition().toJSON();

                gmapServices.reverseGeocode(vm.solar.coordinates)
                    .then(function (result) {
                        var formatted_address = result[0].formatted_address;
                        $log.info(formatted_address);
                        vm.solar.address = formatted_address;
                    });
            }
        }


        function saveArea() {
            if (!drawingServices.overlay) {
                alertServices.showWarningDrawSiteArea();
                return;
            }

            vm.solar.area = drawingServices.overlayDataArray;

            if (vm.areaPolygon) {
                if (!vm.areaPolygon.getMap()) {
                    vm.areaPolygon.setMap(gmapServices.map);
                }
                gmapServices.updatePolygon(vm.areaPolygon, vm.solar.area);
            } else {
                vm.areaPolygon = gmapServices.createPolygon(vm.solar.area);
            }

            vm.stopDrawingMode();
        }


        function cancelDrawing() {
            if (vm.areaPolygon && !vm.areaPolygon.getMap()) {
                gmapServices.showPolygon(vm.areaPolygon);
            } else {
                vm.areaPolygon = null;
            }

            vm.stopDrawingMode();
        }


        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                $rootScope.showDeleteSelectedBtn = false;
                $rootScope.showSaveAreaBtn = false;
            }
        }


        function cleanUp() {
            hideAreaPolygon();
            hideCurrentMarker();
            vm.stopDrawingMode();
            vm.areaPolygon = null;
            vm.currentMarker = null;
        }


        function hideCurrentMarker() {
            if (vm.currentMarker) {
                gmapServices.hideMarker(vm.currentMarker);
            }
        }


        function hideAreaPolygon() {
            if (vm.areaPolygon) {
                gmapServices.hidePolygon(vm.areaPolygon);
            }
        }

    }
}());
(function(){
    'use strict';

    var usStates = [
        "Alabama",
        "Alaska",
        "American Samoa",
        "Arizona",
        "Arkansas",
        "California",
        "Colorado",
        "Connecticut",
        "Delaware",
        "District Of Columbia",
        "Federated States Of Micronesia",
        "Florida",
        "Georgia",
        "Guam",
        "Hawaii",
        "Idaho",
        "Illinois",
        "Indiana",
        "Iowa",
        "Kansas",
        "Kentucky",
        "Louisiana",
        "Maine",
        "Marshall Islands",
        "Maryland",
        "Massachusetts",
        "Michigan",
        "Minnesota",
        "Mississippi",
        "Missouri",
        "Montana",
        "Nebraska",
        "Nevada",
        "New Hampshire",
        "New Jersey",
        "New Mexico",
        "New York",
        "North Carolina",
        "North Dakota",
        "Northern Mariana Islands",
        "Ohio",
        "Oklahoma",
        "Oregon",
        "Palau",
        "Pennsylvania",
        "Puerto Rico",
        "Rhode Island",
        "South Carolina",
        "South Dakota",
        "Tennessee",
        "Texas",
        "Utah",
        "Vermont",
        "Virgin Islands",
        "Virginia",
        "Washington",
        "West Virginia",
        "Wisconsin",
        "Wyoming"
    ];

    var solarStatuses = [
        'In-Process',
        'Submitted',
        'Approved'
    ];

    angular.module('solarApp')
        .value('usStates', usStates)
        .value('solarStatuses', solarStatuses);

}());


